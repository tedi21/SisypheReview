/*
 * DebugEngineInterpreter_impl.hpp
 *
 *
 * @date 02-08-2019
 * @author Teddy DIDE
 * @version 1.00
 * Debug Interpreter generated by gensources.
 */

#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(interp)


template <class EncodingT>
DebugEngineInterpreter<EncodingT>::DebugEngineInterpreter()
{
m_debugClient = NULL;
  m_eventCallback = NULL;
  m_debugControl = NULL;
  m_debugSystemObjects = NULL;
  m_debugSymbols = NULL;
}

template <class EncodingT>
DebugEngineInterpreter<EncodingT>::~DebugEngineInterpreter()
{
	tidyValue();
}

template <class EncodingT>
void DebugEngineInterpreter<EncodingT>::tidyValue()
{
terminate();
}

template <class EncodingT>
typename EncodingT::string_t DebugEngineInterpreter<EncodingT>::toString() const
{
	return EncodingT::EMPTY;
}

template <class EncodingT>
boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::clone() const
{
	return boost::shared_ptr< Base<EncodingT> >(new DebugEngineInterpreter<EncodingT>(*this));
}

template <class EncodingT>
typename EncodingT::string_t DebugEngineInterpreter<EncodingT>::getClassName() const
{
	return UCS("DebugEngine");
}

template <class EncodingT>
boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::invoke(const typename EncodingT::string_t& method, std::vector< boost::shared_ptr< Base<EncodingT> > >& params)
{
	boost::shared_ptr< Base<EncodingT> > obj(new Base<EncodingT>());
	ParameterArray args, ret;
	if (check_parameters_array(params, args))
	{
		if (tryInvoke(this, UCS("DebugEngine"), method, args, ret) ||
			tryInvoke(this, UCS("Base"), method, args, ret))
		{
			find_parameter(ret, FACTORY_RETURN_PARAMETER, obj);
			for (size_t i = 0; i < params.size(); ++i)
			{
				find_parameter(ret, i, params[i]);
			}
		}
		else
		{
			Category* logger = &Category::getInstance(LOGNAME);
			logger->errorStream() << "Unexpected call in DebugEngine, no method \"" << A(method) << "\" exists.";
		}
	}
	return obj;
}

// Initialise le moteur de débogage.
template <class EncodingT>
boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::initialize()
{
if (m_debugClient == NULL)
  {
    HRESULT hr = DebugCreate(IID_IDebugClient, (void**)&m_debugClient);
    if(SUCCEEDED(hr))
    {  
        hr = m_debugClient->QueryInterface(IID_IDebugControl3, (void**)&m_debugControl);
        if (SUCCEEDED(hr))
        {
            m_eventCallback = new EventCallbacks<EncodingT>(this, m_debugControl);
            hr = m_debugClient->SetEventCallbacks(m_eventCallback);
        }
        hr = m_debugClient->QueryInterface(IID_IDebugSystemObjects, (void**)&m_debugSystemObjects);
        hr = m_debugClient->QueryInterface(IID_IDebugSymbols, (void**)&m_debugSymbols);
    }
  }
  return boost::shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient != NULL));
}

// Libère les objets debug.
template <class EncodingT>
boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::terminate()
{
m_triggeredBreakpoints.clear();
  if(m_debugSymbols != NULL)
  {
    m_debugSymbols->Release();
    m_debugSymbols = NULL;
  }
  if(m_debugSystemObjects != NULL)
  {
    m_debugSystemObjects->Release();
    m_debugSystemObjects = NULL;
  }
  if (m_eventCallback != NULL)
  {
    delete m_eventCallback;
    m_eventCallback = NULL;
  }
  if(m_debugControl != NULL)
  {
    m_debugControl->Release();
    m_debugControl = NULL;
  }
  if(m_debugClient != NULL)
  {
    m_debugClient->EndSession(DEBUG_END_PASSIVE);
    m_debugClient->Release();
    m_debugClient = NULL;
  }
  return boost::shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient == NULL));
}

// Allocate additional memory to the target process.
template <class EncodingT>
boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::dvAlloc(const boost::shared_ptr< Base<EncodingT> >& size)
{
boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  if (m_debugSystemObjects != NULL)
  {
    unsigned long nativeSize;
    if (check_numeric_i(size, nativeSize))
    {
      unsigned long long hProcess;
      HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
      if (SUCCEEDED(hr))
      {
        res.reset(new Numeric<EncodingT>((unsigned long long) VirtualAllocEx((HANDLE) hProcess, NULL, nativeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)));
      }
    }
  }
  return res;
}

// Frees a memory allocation owned by the target process.
template <class EncodingT>
boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::dvFree(const boost::shared_ptr< Base<EncodingT> >& baseAddress, const boost::shared_ptr< Base<EncodingT> >& size)
{
boost::shared_ptr< Base<EncodingT> > res(new Bool<EncodingT>(false));
  if (m_debugSystemObjects != NULL)
  {
    unsigned long nativeSize;
    int nativeBaseAddress;
    if (check_numeric_i(baseAddress, nativeBaseAddress) && check_numeric_i(size, nativeSize))
    {
      unsigned long long hProcess;
      HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
      if (SUCCEEDED(hr))
      {
          res.reset(new Bool<EncodingT>(VirtualFreeEx((HANDLE) hProcess, (LPVOID)nativeBaseAddress, nativeSize, MEM_RELEASE)));
      }
    }
  }
  return res;
}
// Retourne l'objet DebugClient
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugClient() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugClientPtrInterpreter<EncodingT>(IDebugClientPtr(m_debugClient)));
  }
  
  // Retourne l'objet DebugControl
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugControl() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugControlPtrInterpreter<EncodingT>(IDebugControlPtr(m_debugControl)));
  }
  
  // Retourne l'objet DebugSystemObjects
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSystemObjects() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugSystemObjectsPtrInterpreter<EncodingT>(IDebugSystemObjectsPtr(m_debugSystemObjects)));
  }
 
  // Retourne l'objet DebugSymbols
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSymbols() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugSymbolsPtrInterpreter<EncodingT>(IDebugSymbolsPtr(m_debugSymbols)));
  }
  
  // Ajoute l'objet TriggeredBreakpoint
  template <class EncodingT>
  void DebugEngineInterpreter<EncodingT>::AddTriggeredBreakpoint(IDebugBreakpoint* const breakpoint)
  {
    m_triggeredBreakpoints.push_back(breakpoint);
  }
  
  // Réinitialise l'objet DebugBreakpoint
  template <class EncodingT>
  void DebugEngineInterpreter<EncodingT>::ResetTriggeredBreakpoint()
  {
    m_triggeredBreakpoints.clear();
  }
  
  // Retourne le nombre d'objet DebugBreakpoint
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getTriggeredBreakpointsCount() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new Numeric<EncodingT>(m_triggeredBreakpoints.size()));
  }
  
  // Retourne l'objet TriggeredBreakpoint
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getTriggeredBreakpoint(const boost::shared_ptr< Base<EncodingT> >& i) const
  {
    IDebugBreakpoint * bp = NULL;
    size_t index = 0;
    if (check_numeric_i(i, index))
    {
        if (check_index(index, m_triggeredBreakpoints.size()))
        {
            bp = m_triggeredBreakpoints[index];
        }
    }
    return boost::shared_ptr< Base<EncodingT> > (new IDebugBreakpointPtrInterpreter<EncodingT>(bp));
  }

NAMESPACE_END

template <class EncodingT>
EventCallbacks<EncodingT>::EventCallbacks(interp::DebugEngineInterpreter<EncodingT> *owner, IDebugControl3 *control)
: m_Owner(owner), m_Control(control), m_Breakpoint(NULL)
{
}

template <class EncodingT>
EventCallbacks<EncodingT>::~EventCallbacks()
{
      if (m_Control && m_Breakpoint)
      {
            HRESULT status = m_Control->RemoveBreakpoint(m_Breakpoint);
            if (status == S_OK)
            {
                   m_Breakpoint = NULL;
            }
       }
}

template <class EncodingT>
STDMETHODIMP_(ULONG) EventCallbacks<EncodingT>::AddRef( THIS )  // event callback method 1
{
       return 1;
}
template <class EncodingT>
STDMETHODIMP_(ULONG) EventCallbacks<EncodingT>::Release( THIS )  //event callback method 2
{
       return 0;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::Breakpoint( THIS_ IN PDEBUG_BREAKPOINT Bp ) //event callback method 3
{
       if (m_Owner != NULL) 
       {
            m_Owner->AddTriggeredBreakpoint(Bp);
       }
       return DEBUG_STATUS_BREAK;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::CreateProcess(THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle,
       IN ULONG64 BaseOffset,IN ULONG ModuleSize,IN PCSTR ModuleName,IN PCSTR ImageName,
       IN ULONG CheckSum, IN ULONG TimeDateStamp,IN ULONG64 InitialThreadHandle,
       IN ULONG64 ThreadDataOffset,  IN ULONG64 StartOffset
       ) //event callback method 4  and so on till method 16
{
       if (m_Control)
       {
             HRESULT status = 0; //we are setting a break point in Address Of Entrypoint of the debuggee
             IDebugBreakpoint* breakpoint = NULL;
             if ((status = m_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE,DEBUG_ANY_ID, &breakpoint)) == S_OK)
             {
                    if (( status = breakpoint->SetOffset(StartOffset)) == S_OK)
                    {
                           if (( status = breakpoint->SetFlags(DEBUG_BREAKPOINT_ENABLED)) == S_OK)
                           {
                                  m_Breakpoint = breakpoint;
                           }
                    }
             }
       }
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::CreateThread( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset, IN ULONG64  StartOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::Exception( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance )
{
       HRESULT hres = DEBUG_STATUS_BREAK;
       if (Exception != NULL && Exception->ExceptionCode == 0x406D1388)
       {
               hres = DEBUG_STATUS_NO_CHANGE;
       }
       return hres;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ExitProcess (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ExitThread (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::GetInterestMask( THIS_ OUT PULONG Mask )
{
       *Mask =
              DEBUG_EVENT_BREAKPOINT |
              DEBUG_EVENT_EXCEPTION |
              DEBUG_EVENT_CREATE_THREAD |
              DEBUG_EVENT_EXIT_THREAD |
              DEBUG_EVENT_CREATE_PROCESS |
              DEBUG_EVENT_EXIT_PROCESS |
              DEBUG_EVENT_LOAD_MODULE |
              DEBUG_EVENT_UNLOAD_MODULE |
              DEBUG_EVENT_SYSTEM_ERROR |
              DEBUG_EVENT_SESSION_STATUS |
              DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
              DEBUG_EVENT_CHANGE_ENGINE_STATE |
              DEBUG_EVENT_CHANGE_SYMBOL_STATE;
       return S_OK;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::LoadModule( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,
       IN ULONG ModuleSize,IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum, IN ULONG TimeDateStamp )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::SystemError( THIS_ IN ULONG  Error, IN ULONG  Level )
{
       return DEBUG_STATUS_BREAK;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::UnloadModule( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::SessionStatus( THIS_ IN ULONG SessionStatus )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ChangeDebuggeeState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ChangeEngineState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       if ((m_Owner != NULL) && (DEBUG_CES_EXECUTION_STATUS == Flags) && 
           (DEBUG_STATUS_BREAK != Argument) && (DEBUG_STATUS_NO_CHANGE != Argument) && (DEBUG_STATUS_NO_DEBUGGEE != Argument))
       {
              m_Owner->ResetTriggeredBreakpoint();  
       }
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ChangeSymbolState( THIS_ IN ULONG Flags, IN ULONG64 Argument ) // method 16
{
       return DEBUG_STATUS_NO_CHANGE;
}

#undef A
#undef C