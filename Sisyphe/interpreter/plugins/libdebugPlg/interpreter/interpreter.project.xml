<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE document_schema SYSTEM "document_schema.dtd">
<document_schema>

  <Workspace Author="Teddy DIDE" Brief="Debug Interpreter generated by gensources." Name="Debug_interpreter" Option="1" Type="Project" Version="1.00">
    <File Name="DebugEngine">
      <Content Type="Global-inclusion">&#xD;
#include "IDebugClientPtrInterpreter.hpp"&#xD;
#include "IDebugControlPtrInterpreter.hpp"&#xD;
#include "IDebugSystemObjectsPtrInterpreter.hpp"&#xD;
#include "IDebugSymbolsPtrInterpreter.hpp"&#xD;
#include "IDebugBreakpointPtrInterpreter.hpp"&#xD;
&#xD;
NAMESPACE_BEGIN(interp)&#xD;
  template &lt;class EncodingT&gt;&#xD;
  class DebugEngineInterpreter;&#xD;
NAMESPACE_END&#xD;
&#xD;
template &lt;class EncodingT&gt;&#xD;
class EventCallbacks : public DebugBaseEventCallbacks   // event callback class has 16 methods&#xD;
{&#xD;
private:&#xD;
  interp::DebugEngineInterpreter&lt;EncodingT&gt; *m_Owner;&#xD;
  CDebugPtr&lt;IDebugControl3&gt;  m_Control;&#xD;
  IDebugBreakpoint* m_Breakpoint;&#xD;
&#xD;
public:&#xD;
       EventCallbacks(interp::DebugEngineInterpreter&lt;EncodingT&gt; *owner, IDebugControl3 *control);&#xD;
       ~EventCallbacks();&#xD;
       STDMETHOD_(ULONG, AddRef)         ( THIS );&#xD;
       STDMETHOD_(ULONG, Release)        ( THIS );&#xD;
       STDMETHOD(Breakpoint)             ( THIS_ IN PDEBUG_BREAKPOINT Bp );&#xD;
       STDMETHOD(ChangeDebuggeeState)    ( THIS_ IN ULONG Flags, IN ULONG64  Argument );&#xD;
       STDMETHOD(ChangeEngineState)      ( THIS_ IN ULONG Flags, IN ULONG64  Argument );&#xD;
       STDMETHOD(ChangeSymbolState)      ( THIS_ IN ULONG Flags, IN ULONG64  Argument );&#xD;
       STDMETHOD(CreateThread)           ( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset,IN ULONG64  StartOffset);&#xD;
       STDMETHOD(Exception)              ( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance );&#xD;
       STDMETHOD(ExitProcess)            ( THIS_ IN ULONG  ExitCode );&#xD;
       STDMETHOD(ExitThread)             ( THIS_ IN ULONG  ExitCode );&#xD;
       STDMETHOD(GetInterestMask)        ( THIS_ OUT PULONG Mask );&#xD;
       STDMETHOD(SessionStatus)          ( THIS_ IN ULONG Status );&#xD;
       STDMETHOD(SystemError)            ( THIS_ IN ULONG  Error, IN ULONG  Level );&#xD;
       STDMETHOD(UnloadModule)           ( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset );&#xD;
       STDMETHOD(LoadModule)             (  THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,&#xD;
                                          IN ULONG ModuleSize,  IN PCSTR ModuleName,IN PCSTR ImageName,  IN ULONG CheckSum,&#xD;
                                          IN ULONG TimeDateStamp );&#xD;
       STDMETHOD(CreateProcess)          ( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle, IN ULONG64 BaseOffset, IN ULONG ModuleSize, &#xD;
                                          IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum,&#xD;
                                          IN ULONG TimeDateStamp,  IN ULONG64 InitialThreadHandle,   IN ULONG64 ThreadDataOffset,&#xD;
                                          IN ULONG64 StartOffset );&#xD;
};&#xD;
</Content>
      <Content Type="Global-body">&#xD;
template &lt;class EncodingT&gt;&#xD;
EventCallbacks&lt;EncodingT&gt;::EventCallbacks(interp::DebugEngineInterpreter&lt;EncodingT&gt; *owner, IDebugControl3 *control)&#xD;
: m_Owner(owner), m_Control(control), m_Breakpoint(NULL)&#xD;
{&#xD;
}&#xD;
&#xD;
template &lt;class EncodingT&gt;&#xD;
EventCallbacks&lt;EncodingT&gt;::~EventCallbacks()&#xD;
{&#xD;
      if (m_Control &amp;&amp; m_Breakpoint)&#xD;
      {&#xD;
            HRESULT status = m_Control-&gt;RemoveBreakpoint(m_Breakpoint);&#xD;
            if (status == S_OK)&#xD;
            {&#xD;
                   m_Breakpoint = NULL;&#xD;
            }&#xD;
       }&#xD;
}&#xD;
&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP_(ULONG) EventCallbacks&lt;EncodingT&gt;::AddRef( THIS )  // event callback method 1&#xD;
{&#xD;
       return 1;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP_(ULONG) EventCallbacks&lt;EncodingT&gt;::Release( THIS )  //event callback method 2&#xD;
{&#xD;
       return 0;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::Breakpoint( THIS_ IN PDEBUG_BREAKPOINT Bp ) //event callback method 3&#xD;
{&#xD;
       if (m_Owner != NULL) &#xD;
       {&#xD;
            m_Owner-&gt;AddTriggeredBreakpoint(Bp);&#xD;
       }&#xD;
       return DEBUG_STATUS_BREAK;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::CreateProcess(THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle,&#xD;
       IN ULONG64 BaseOffset,IN ULONG ModuleSize,IN PCSTR ModuleName,IN PCSTR ImageName,&#xD;
       IN ULONG CheckSum, IN ULONG TimeDateStamp,IN ULONG64 InitialThreadHandle,&#xD;
       IN ULONG64 ThreadDataOffset,  IN ULONG64 StartOffset&#xD;
       ) //event callback method 4  and so on till method 16&#xD;
{&#xD;
       if (m_Control)&#xD;
       {&#xD;
             HRESULT status = 0; //we are setting a break point in Address Of Entrypoint of the debuggee&#xD;
             IDebugBreakpoint* breakpoint = NULL;&#xD;
             if ((status = m_Control-&gt;AddBreakpoint(DEBUG_BREAKPOINT_CODE,DEBUG_ANY_ID, &amp;breakpoint)) == S_OK)&#xD;
             {&#xD;
                    if (( status = breakpoint-&gt;SetOffset(StartOffset)) == S_OK)&#xD;
                    {&#xD;
                           if (( status = breakpoint-&gt;SetFlags(DEBUG_BREAKPOINT_ENABLED)) == S_OK)&#xD;
                           {&#xD;
                                  m_Breakpoint = breakpoint;&#xD;
                           }&#xD;
                    }&#xD;
             }&#xD;
       }&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::CreateThread( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset, IN ULONG64  StartOffset )&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::Exception( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance )&#xD;
{&#xD;
       HRESULT hres = DEBUG_STATUS_BREAK;&#xD;
       if (Exception != NULL &amp;&amp; Exception-&gt;ExceptionCode == 0x406D1388)&#xD;
       {&#xD;
               hres = DEBUG_STATUS_NO_CHANGE;&#xD;
       }&#xD;
       return hres;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::ExitProcess (THIS_ IN ULONG  ExitCode )&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::ExitThread (THIS_ IN ULONG  ExitCode )&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::GetInterestMask( THIS_ OUT PULONG Mask )&#xD;
{&#xD;
       *Mask =&#xD;
              DEBUG_EVENT_BREAKPOINT |&#xD;
              DEBUG_EVENT_EXCEPTION |&#xD;
              DEBUG_EVENT_CREATE_THREAD |&#xD;
              DEBUG_EVENT_EXIT_THREAD |&#xD;
              DEBUG_EVENT_CREATE_PROCESS |&#xD;
              DEBUG_EVENT_EXIT_PROCESS |&#xD;
              DEBUG_EVENT_LOAD_MODULE |&#xD;
              DEBUG_EVENT_UNLOAD_MODULE |&#xD;
              DEBUG_EVENT_SYSTEM_ERROR |&#xD;
              DEBUG_EVENT_SESSION_STATUS |&#xD;
              DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |&#xD;
              DEBUG_EVENT_CHANGE_ENGINE_STATE |&#xD;
              DEBUG_EVENT_CHANGE_SYMBOL_STATE;&#xD;
       return S_OK;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::LoadModule( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,&#xD;
       IN ULONG ModuleSize,IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum, IN ULONG TimeDateStamp )&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::SystemError( THIS_ IN ULONG  Error, IN ULONG  Level )&#xD;
{&#xD;
       return DEBUG_STATUS_BREAK;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::UnloadModule( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset )&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::SessionStatus( THIS_ IN ULONG SessionStatus )&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::ChangeDebuggeeState( THIS_ IN ULONG Flags, IN ULONG64 Argument )&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::ChangeEngineState( THIS_ IN ULONG Flags, IN ULONG64 Argument )&#xD;
{&#xD;
       if ((m_Owner != NULL) &amp;&amp; (DEBUG_CES_EXECUTION_STATUS == Flags) &amp;&amp; &#xD;
           (DEBUG_STATUS_BREAK != Argument) &amp;&amp; (DEBUG_STATUS_NO_CHANGE != Argument) &amp;&amp; (DEBUG_STATUS_NO_DEBUGGEE != Argument))&#xD;
       {&#xD;
              m_Owner-&gt;ResetTriggeredBreakpoint();  &#xD;
       }&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
template &lt;class EncodingT&gt;&#xD;
STDMETHODIMP EventCallbacks&lt;EncodingT&gt;::ChangeSymbolState( THIS_ IN ULONG Flags, IN ULONG64 Argument ) // method 16&#xD;
{&#xD;
       return DEBUG_STATUS_NO_CHANGE;&#xD;
}&#xD;
</Content>
      <Content Type="Declaration">&#xD;
private:&#xD;
  IDebugClient *m_debugClient;&#xD;
  EventCallbacks&lt;EncodingT&gt; *m_eventCallback;&#xD;
  IDebugControl3 *m_debugControl;&#xD;
  IDebugSystemObjects *m_debugSystemObjects;&#xD;
  IDebugSymbols *m_debugSymbols;&#xD;
  std::vector&lt;IDebugBreakpoint *&gt; m_triggeredBreakpoints;&#xD;
  &#xD;
public:&#xD;
  // Retourne l'objet DebugClient&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; getDebugClient() const;&#xD;
  &#xD;
  // Retourne l'objet DebugControl&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; getDebugControl() const;&#xD;
  &#xD;
  // Retourne l'objet DebugSystemObjects&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; getDebugSystemObjects() const;&#xD;
  &#xD;
  // Retourne l'objet DebugSymbols&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; getDebugSymbols() const;&#xD;
&#xD;
  // Ajoute l'objet DebugBreakpoint&#xD;
  void AddTriggeredBreakpoint(IDebugBreakpoint* const breakpoint);&#xD;
  &#xD;
  // Réinitialise l'objet DebugBreakpoint&#xD;
  void ResetTriggeredBreakpoint();&#xD;
  &#xD;
  // Retourne le nombre d'objet DebugBreakpoint&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; getTriggeredBreakpointsCount() const;&#xD;
  &#xD;
  // Retourne l'objet DebugBreakpoint&#xD;
  FACTORY_PROTOTYPE1(getTriggeredBreakpoint, In&lt; boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; &gt;)&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; getTriggeredBreakpoint(const boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;&amp; i) const;&#xD;
</Content>
      <Content Type="Implementation">&#xD;
  // Retourne l'objet DebugClient&#xD;
  template &lt;class EncodingT&gt;&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; DebugEngineInterpreter&lt;EncodingT&gt;::getDebugClient() const&#xD;
  {&#xD;
    return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new IDebugClientPtrInterpreter&lt;EncodingT&gt;(IDebugClientPtr(m_debugClient)));&#xD;
  }&#xD;
  &#xD;
  // Retourne l'objet DebugControl&#xD;
  template &lt;class EncodingT&gt;&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; DebugEngineInterpreter&lt;EncodingT&gt;::getDebugControl() const&#xD;
  {&#xD;
    return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new IDebugControlPtrInterpreter&lt;EncodingT&gt;(IDebugControlPtr(m_debugControl)));&#xD;
  }&#xD;
  &#xD;
  // Retourne l'objet DebugSystemObjects&#xD;
  template &lt;class EncodingT&gt;&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; DebugEngineInterpreter&lt;EncodingT&gt;::getDebugSystemObjects() const&#xD;
  {&#xD;
    return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new IDebugSystemObjectsPtrInterpreter&lt;EncodingT&gt;(IDebugSystemObjectsPtr(m_debugSystemObjects)));&#xD;
  }&#xD;
 &#xD;
  // Retourne l'objet DebugSymbols&#xD;
  template &lt;class EncodingT&gt;&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; DebugEngineInterpreter&lt;EncodingT&gt;::getDebugSymbols() const&#xD;
  {&#xD;
    return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new IDebugSymbolsPtrInterpreter&lt;EncodingT&gt;(IDebugSymbolsPtr(m_debugSymbols)));&#xD;
  }&#xD;
  &#xD;
  // Ajoute l'objet TriggeredBreakpoint&#xD;
  template &lt;class EncodingT&gt;&#xD;
  void DebugEngineInterpreter&lt;EncodingT&gt;::AddTriggeredBreakpoint(IDebugBreakpoint* const breakpoint)&#xD;
  {&#xD;
    m_triggeredBreakpoints.push_back(breakpoint);&#xD;
  }&#xD;
  &#xD;
  // Réinitialise l'objet DebugBreakpoint&#xD;
  template &lt;class EncodingT&gt;&#xD;
  void DebugEngineInterpreter&lt;EncodingT&gt;::ResetTriggeredBreakpoint()&#xD;
  {&#xD;
    m_triggeredBreakpoints.clear();&#xD;
  }&#xD;
  &#xD;
  // Retourne le nombre d'objet DebugBreakpoint&#xD;
  template &lt;class EncodingT&gt;&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; DebugEngineInterpreter&lt;EncodingT&gt;::getTriggeredBreakpointsCount() const&#xD;
  {&#xD;
    return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new Numeric&lt;EncodingT&gt;(m_triggeredBreakpoints.size()));&#xD;
  }&#xD;
  &#xD;
  // Retourne l'objet TriggeredBreakpoint&#xD;
  template &lt;class EncodingT&gt;&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; DebugEngineInterpreter&lt;EncodingT&gt;::getTriggeredBreakpoint(const boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;&amp; i) const&#xD;
  {&#xD;
    IDebugBreakpoint * bp = NULL;&#xD;
    size_t index = 0;&#xD;
    if (check_numeric_i(i, index))&#xD;
    {&#xD;
        if (check_index(index, m_triggeredBreakpoints.size()))&#xD;
        {&#xD;
            bp = m_triggeredBreakpoints[index];&#xD;
        }&#xD;
    }&#xD;
    return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new IDebugBreakpointPtrInterpreter&lt;EncodingT&gt;(bp));&#xD;
  }&#xD;
</Content>
      <Content Type="Register">&#xD;
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;, getDebugClient, const_t, C("DebugEngine::DebugClient") );&#xD;
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;, getDebugControl, const_t, C("DebugEngine::DebugControl") );&#xD;
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;, getDebugSystemObjects, const_t, C("DebugEngine::DebugSystemObjects") );&#xD;
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;, getDebugSymbols, const_t, C("DebugEngine::DebugSymbols") );&#xD;
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;, getTriggeredBreakpointsCount, const_t, C("DebugEngine::TriggeredBreakpointsCount") );&#xD;
METHOD_KEY_REGISTER1( DebugEngineInterpreter, boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt;, getTriggeredBreakpoint, const_t, C("DebugEngine::GetTriggeredBreakpoint") );&#xD;
</Content>
      <Content Type="Unregister">&#xD;
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugClient") );&#xD;
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugControl") );&#xD;
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugSystemObjects") );&#xD;
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugSymbols") );&#xD;
METHOD_KEY_UNREGISTER ( C("DebugEngine::TriggeredBreakpointsCount") );&#xD;
METHOD_KEY_UNREGISTER1( C("DebugEngine::GetTriggeredBreakpoint") );&#xD;
</Content>
      <Content Type="Initialization-body">&#xD;
  m_debugClient = NULL;&#xD;
  m_eventCallback = NULL;&#xD;
  m_debugControl = NULL;&#xD;
  m_debugSystemObjects = NULL;&#xD;
  m_debugSymbols = NULL;&#xD;
</Content>
      <Content Type="Destruction-body">&#xD;
  terminate();&#xD;
</Content>
      <Content Target="DebugEngine:initialize@Boolean" Type="Implementation-body">&#xD;
  if (m_debugClient == NULL)&#xD;
  {&#xD;
    HRESULT hr = DebugCreate(IID_IDebugClient, (void**)&amp;m_debugClient);&#xD;
    if(SUCCEEDED(hr))&#xD;
    {  &#xD;
        hr = m_debugClient-&gt;QueryInterface(IID_IDebugControl3, (void**)&amp;m_debugControl);&#xD;
        if (SUCCEEDED(hr))&#xD;
        {&#xD;
            m_eventCallback = new EventCallbacks&lt;EncodingT&gt;(this, m_debugControl);&#xD;
            hr = m_debugClient-&gt;SetEventCallbacks(m_eventCallback);&#xD;
        }&#xD;
        hr = m_debugClient-&gt;QueryInterface(IID_IDebugSystemObjects, (void**)&amp;m_debugSystemObjects);&#xD;
        hr = m_debugClient-&gt;QueryInterface(IID_IDebugSymbols, (void**)&amp;m_debugSymbols);&#xD;
    }&#xD;
  }&#xD;
  return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new Bool&lt;EncodingT&gt;(m_debugClient != NULL));&#xD;
</Content>
      <Content Target="DebugEngine:terminate@Boolean" Type="Implementation-body">&#xD;
  m_triggeredBreakpoints.clear();&#xD;
  if(m_debugSymbols != NULL)&#xD;
  {&#xD;
    m_debugSymbols-&gt;Release();&#xD;
    m_debugSymbols = NULL;&#xD;
  }&#xD;
  if(m_debugSystemObjects != NULL)&#xD;
  {&#xD;
    m_debugSystemObjects-&gt;Release();&#xD;
    m_debugSystemObjects = NULL;&#xD;
  }&#xD;
  if (m_eventCallback != NULL)&#xD;
  {&#xD;
    delete m_eventCallback;&#xD;
    m_eventCallback = NULL;&#xD;
  }&#xD;
  if(m_debugControl != NULL)&#xD;
  {&#xD;
    m_debugControl-&gt;Release();&#xD;
    m_debugControl = NULL;&#xD;
  }&#xD;
  if(m_debugClient != NULL)&#xD;
  {&#xD;
    m_debugClient-&gt;EndSession(DEBUG_END_PASSIVE);&#xD;
    m_debugClient-&gt;Release();&#xD;
    m_debugClient = NULL;&#xD;
  }&#xD;
  return boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; (new Bool&lt;EncodingT&gt;(m_debugClient == NULL));&#xD;
</Content>
      <Content Target="DebugEngine:DvAlloc@Uint32@Int" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  if (m_debugSystemObjects != NULL)&#xD;
  {&#xD;
    unsigned long nativeSize;&#xD;
    if (check_numeric_i(size, nativeSize))&#xD;
    {&#xD;
      unsigned long long hProcess;&#xD;
      HRESULT hr = m_debugSystemObjects-&gt;GetCurrentProcessHandle(&amp;hProcess);&#xD;
      if (SUCCEEDED(hr))&#xD;
      {&#xD;
        res.reset(new Numeric&lt;EncodingT&gt;((unsigned long long) VirtualAllocEx((HANDLE) hProcess, NULL, nativeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)));&#xD;
      }&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="DebugEngine:DvFree@Int@Uint32@Boolean" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Bool&lt;EncodingT&gt;(false));&#xD;
  if (m_debugSystemObjects != NULL)&#xD;
  {&#xD;
    unsigned long nativeSize;&#xD;
    int nativeBaseAddress;&#xD;
    if (check_numeric_i(baseAddress, nativeBaseAddress) &amp;&amp; check_numeric_i(size, nativeSize))&#xD;
    {&#xD;
      unsigned long long hProcess;&#xD;
      HRESULT hr = m_debugSystemObjects-&gt;GetCurrentProcessHandle(&amp;hProcess);&#xD;
      if (SUCCEEDED(hr))&#xD;
      {&#xD;
          res.reset(new Bool&lt;EncodingT&gt;(VirtualFreeEx((HANDLE) hProcess, (LPVOID)nativeBaseAddress, nativeSize, MEM_RELEASE)));&#xD;
      }&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
    </File>
    <File Name="IDebugClientPtr">
      <Entity Class="Data" Name="IDebugClientPtr">
        <Attribute Modifier="Virtual " Name="Id" Type="Any"/>
      </Entity>
      <Content Type="Global-inclusion">&#xD;
#include "DebugPtr.h"&#xD;
typedef CDebugPtr&lt;IDebugClient&gt; IDebugClientPtr;&#xD;
#include "IDebugControlPtrInterpreter.hpp"&#xD;
</Content>
      <Content Target="IDebugClientPtr:CreateProcess@AnsiString@Uint32@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugClientPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    typename EncodingT::string_t nativeCommandLine;&#xD;
    unsigned long nativeCreateFlags;&#xD;
    if (check_string&lt;EncodingT&gt;(commandLine, nativeCommandLine) &amp;&amp; &#xD;
        check_numeric_i(createFlags, nativeCreateFlags))&#xD;
    {&#xD;
          char ansiCommandLine[MAX_PATH];&#xD;
          std::copy(nativeCommandLine.begin(), nativeCommandLine.end(), ansiCommandLine);&#xD;
          res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;CreateProcess(0, ansiCommandLine, nativeCreateFlags)));&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugClientPtr:CreateProcess@AnsiString@Uint32@AnsiString@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugClientPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    typename EncodingT::string_t nativeCommandLine;&#xD;
    typename EncodingT::string_t nativeInitialDirectory;&#xD;
    unsigned long nativeCreateFlags;&#xD;
    if (check_string&lt;EncodingT&gt;(commandLine, nativeCommandLine) &amp;&amp; &#xD;
        check_string&lt;EncodingT&gt;(initialDirectory, nativeInitialDirectory) &amp;&amp; &#xD;
        check_numeric_i(createFlags, nativeCreateFlags))&#xD;
    {&#xD;
          TCHAR cwd[MAX_PATH];&#xD;
          // Retrieves the current directory for the current process.&#xD;
          GetCurrentDirectory(MAX_PATH, cwd);&#xD;
&#xD;
          // Changes the current directory for the current process.&#xD;
          SetCurrentDirectory(nativeInitialDirectory.c_str());&#xD;
&#xD;
          char ansiCommandLine[MAX_PATH];&#xD;
          std::copy(nativeCommandLine.begin(), nativeCommandLine.end(), ansiCommandLine);&#xD;
          res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;CreateProcess(0, ansiCommandLine, nativeCreateFlags)));&#xD;
          &#xD;
          // Reset the current directory&#xD;
          SetCurrentDirectory(cwd);&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugClientPtr:GetRunningProcessSystemIds@Uint32*@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugClientPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    unsigned long nativeId, nativeActualCount;&#xD;
    res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetRunningProcessSystemIds(0, &amp;nativeId, 1, &amp;nativeActualCount)));&#xD;
    reset_numeric_i(processId, nativeId);&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugClientPtr:GetRunningProcessDescription@Uint32@Uint32@AnsiString@AnsiString@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugClientPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    unsigned long nativeSystemId;&#xD;
    unsigned long nativeFlags;&#xD;
    if (check_numeric_i(systemId, nativeSystemId) &amp;&amp; &#xD;
        check_numeric_i(flags, nativeFlags))&#xD;
    {&#xD;
      char ansiNativeExeName[MAX_PATH];&#xD;
      char ansiNativeDescription[MAX_PATH];&#xD;
      unsigned long nativeActualExeNameSize, nativeActualDescriptionSize;&#xD;
      res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetRunningProcessDescription(0, nativeSystemId, nativeFlags, ansiNativeExeName, MAX_PATH, &amp;nativeActualExeNameSize, ansiNativeDescription, MAX_PATH, &amp;nativeActualDescriptionSize)));&#xD;
      reset_string&lt;ansi&gt;(exeName, ansiNativeExeName);&#xD;
      reset_string&lt;ansi&gt;(description, ansiNativeDescription);&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
    </File>
    <File Name="IDebugControlPtr">
      <Entity Class="Data" Name="IDebugControlPtr">
        <Attribute Modifier="Virtual " Name="Id" Type="Any"/>
      </Entity>
      <Content Type="Global-inclusion">&#xD;
#include "DebugPtr.h"&#xD;
typedef CDebugPtr&lt;IDebugControl3&gt; IDebugControlPtr;&#xD;
#include "IDebugBreakpointPtrInterpreter.hpp"&#xD;
#include "DEBUG_STACK_FRAMEInterpreter.hpp"&#xD;
</Content>
      <Content Target="IDebugControlPtr:GetPromptText@AnsiString@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugControlPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    char nativeBuffer[2048];&#xD;
    res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetPromptText(nativeBuffer, 2048, NULL)));&#xD;
    reset_string&lt;ansi&gt;(buffer, nativeBuffer);&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugControlPtr:GetStackTrace@UInt64@UInt64@UInt64@DEBUG_STACK_FRAME@UInt32@UInt32*@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugControlPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    unsigned long long nativeFrameOffset;&#xD;
    unsigned long long nativeStackOffset;&#xD;
    unsigned long long nativeInstructionOffset;&#xD;
    std::vector&lt; DEBUG_STACK_FRAME &gt; nativeFrames;&#xD;
    unsigned long nativeFrameSize;&#xD;
    unsigned long nativeFramesFilled;&#xD;
    if (check_numeric_i(frameOffset, nativeFrameOffset) &amp;&amp;&#xD;
      check_numeric_i(stackOffset, nativeStackOffset) &amp;&amp;&#xD;
      check_numeric_i(instructionOffset, nativeInstructionOffset) &amp;&amp;&#xD;
      check_array(frames, nativeFrames, check_DEBUG_STACK_FRAME&lt;EncodingT&gt;) &amp;&amp;&#xD;
      check_numeric_i(frameSize, nativeFrameSize) &amp;&amp;&#xD;
      check_numeric_i(framesFilled, nativeFramesFilled))&#xD;
    {&#xD;
      nativeFrames.resize(nativeFrameSize);&#xD;
      res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetStackTrace(nativeFrameOffset, nativeStackOffset, nativeInstructionOffset, nativeFrames.data(), nativeFrameSize, &amp;nativeFramesFilled)));&#xD;
      boost::shared_ptr&lt; Array&lt;EncodingT&gt; &gt; framesArray  = dynamic_pointer_cast&lt; Array&lt;EncodingT&gt; &gt;(frames);&#xD;
      if (framesArray)&#xD;
      {&#xD;
          for (size_t i = 0; i &lt; nativeFramesFilled; ++i)&#xD;
          {&#xD;
            boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; item(new DEBUG_STACK_FRAMEInterpreter&lt;EncodingT&gt;(nativeFrames[i]));&#xD;
            framesArray-&gt;addValue(item);&#xD;
          }&#xD;
      }&#xD;
      reset_numeric_i(framesFilled, nativeFramesFilled);&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
    </File>
    <File Name="DebugStatus">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="CreateFlags">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="WaitFlags">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="TimeOut">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="DEBUG_VALUE">
      <Content Type="Global-inclusion">&#xD;
</Content>      <Content Target="DEBUG_VALUE" TargetREF="I8" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((char) value().I8));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="I16" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((short) value().I16));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="I32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((int) value().I32));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="I64" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((long long) value().I64));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="UI8" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((unsigned char) value().I8));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="UI16" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((unsigned short) value().I16));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="UI32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((unsigned int) value().I32));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="UI64" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;((unsigned long long) value().I64));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="C8" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new String&lt;EncodingT&gt;((char) value().I8));&#xD;
  return res;&#xD;
</Content>
      <Content Target="DEBUG_VALUE" TargetREF="C16" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new String&lt;EncodingT&gt;((wchar_t) value().I16));&#xD;
  return res;&#xD;
</Content>
    </File>
    <File Name="DebugValue">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="DebugExecute">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="DebugOutCTL">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="IDebugSystemObjectsPtr">
      <Entity Class="Data" Name="IDebugSystemObjectsPtr">
        <Attribute Modifier="Virtual " Name="Id" Type="Any"/>
      </Entity>
      <Content Type="Global-inclusion">&#xD;
#include "DebugPtr.h"&#xD;
typedef CDebugPtr&lt;IDebugSystemObjects&gt; IDebugSystemObjectsPtr;&#xD;
</Content>
      <Content Target="IDebugSystemObjectsPtr:GetCurrentProcessExecutableName@AnsiString@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugSystemObjectsPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    char nativeBuffer[MAX_PATH];&#xD;
    res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetCurrentProcessExecutableName(nativeBuffer, MAX_PATH, NULL)));&#xD;
    reset_string&lt;ansi&gt;(buffer, nativeBuffer);&#xD;
  }&#xD;
  return res;&#xD;
</Content>
    </File>
    <File Name="IDebugSymbolsPtr">
      <Entity Class="Data" Name="IDebugSymbolsPtr">
        <Attribute Modifier="Virtual " Name="Id" Type="Any"/>
      </Entity>
      <Content Type="Global-inclusion">&#xD;
#include "DebugPtr.h"&#xD;
typedef CDebugPtr&lt;IDebugSymbols&gt; IDebugSymbolsPtr;&#xD;
</Content>
      <Content Target="IDebugSymbolsPtr:GetSymbolPath@AnsiString@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugSymbolsPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    char nativeBuffer[2048];&#xD;
    ZeroMemory(nativeBuffer, 2048);&#xD;
    res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetSymbolPath(nativeBuffer, 2048, NULL)));&#xD;
    reset_string&lt;ansi&gt;(buffer, nativeBuffer);&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugSymbolsPtr:GetLineByOffset@UInt64@UInt32*@AnsiString@UInt64*@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugSymbolsPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    unsigned long long nativeOffset;&#xD;
    unsigned long nativeLine;&#xD;
    char nativeFileBuffer[2048];&#xD;
    ZeroMemory(nativeFileBuffer, 2048);&#xD;
    unsigned long long nativeDisplacement;&#xD;
    if (check_numeric_i(offset, nativeOffset) &amp;&amp; &#xD;
        check_numeric_i(line, nativeLine) &amp;&amp;&#xD;
        check_numeric_i(displacement, nativeDisplacement))&#xD;
    {&#xD;
      res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetLineByOffset(nativeOffset, &amp;nativeLine, nativeFileBuffer, 2048, NULL, &amp;nativeDisplacement)));&#xD;
      reset_numeric_i(line, nativeLine);&#xD;
      reset_string&lt;ansi&gt;(fileBuffer, nativeFileBuffer);&#xD;
      reset_numeric_i(displacement, nativeDisplacement);&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugSymbolsPtr:GetNameByOffset@UInt64@AnsiString@UInt64*@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugSymbolsPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    unsigned long long nativeOffset;&#xD;
    char nativeNameBuffer[2048];&#xD;
    ZeroMemory(nativeNameBuffer, 2048);&#xD;
    unsigned long long nativeDisplacement;&#xD;
    if (check_numeric_i(offset, nativeOffset) &amp;&amp;&#xD;
        check_numeric_i(displacement, nativeDisplacement))&#xD;
    {&#xD;
      res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetNameByOffset(nativeOffset, nativeNameBuffer, 2048, NULL, &amp;nativeDisplacement)));&#xD;
      reset_string&lt;ansi&gt;(nameBuffer, nativeNameBuffer);&#xD;
      reset_numeric_i(displacement, nativeDisplacement);&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugSymbolsPtr:GetNearNameByOffset@UInt64@Int32@AnsiString@UInt64*@Int32" Type="Implementation-body">&#xD;
  boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
  IDebugSymbolsPtr valuePtr = value();&#xD;
  if (valuePtr != NULL)&#xD;
  {&#xD;
    unsigned long long nativeOffset;&#xD;
    long nativeDelta;&#xD;
    char nativeNameBuffer[2048];&#xD;
    ZeroMemory(nativeNameBuffer, 2048);&#xD;
    unsigned long long nativeDisplacement;&#xD;
    if (check_numeric_i(offset, nativeOffset) &amp;&amp; &#xD;
        check_numeric_i(delta, nativeDelta) &amp;&amp;&#xD;
        check_numeric_i(displacement, nativeDisplacement))&#xD;
    {&#xD;
      res.reset(new Numeric&lt;EncodingT&gt;(valuePtr-&gt;GetNearNameByOffset(nativeOffset, nativeDelta, nativeNameBuffer, 2048, NULL, &amp;nativeDisplacement)));&#xD;
      reset_string&lt;ansi&gt;(nameBuffer, nativeNameBuffer);&#xD;
      reset_numeric_i(displacement, nativeDisplacement);&#xD;
    }&#xD;
  }&#xD;
  return res;&#xD;
</Content>
      <Content Target="IDebugSymbolsPtr:GetSourceFileLineOffsets@AnsiString@UInt64@Int32" Type="Implementation-body">&#xD;
	boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; res(new Numeric&lt;EncodingT&gt;());&#xD;
	IDebugSymbolsPtr valuePtr = value();&#xD;
	if (valuePtr != NULL)&#xD;
	{&#xD;
		typename ansi::string_t nativeFile;&#xD;
    std::vector&lt; unsigned long long &gt; nativeAddresses;&#xD;
		if (check_string&lt;ansi&gt;(file, nativeFile) &amp;&amp;&#xD;
        check_array(addresses, nativeAddresses, check_numeric_i&lt;EncodingT,unsigned long long&gt;))&#xD;
		{&#xD;
      unsigned long nlines = 0;&#xD;
      HRESULT hr = valuePtr-&gt;GetSourceFileLineOffsets(nativeFile.c_str(), NULL, 0, &amp;nlines);&#xD;
      if (SUCCEEDED(hr))&#xD;
      {&#xD;
        nativeAddresses.resize(nlines);&#xD;
        hr = valuePtr-&gt;GetSourceFileLineOffsets(nativeFile.c_str(), nativeAddresses.data(), nlines, NULL);&#xD;
        boost::shared_ptr&lt; Array&lt;EncodingT&gt; &gt; addressesArray  = dynamic_pointer_cast&lt; Array&lt;EncodingT&gt; &gt;(addresses);&#xD;
        if (addressesArray)&#xD;
        {&#xD;
            for (size_t i = 0; i &lt; nlines; ++i)&#xD;
            {&#xD;
              boost::shared_ptr&lt; Base&lt;EncodingT&gt; &gt; item(new Numeric&lt;EncodingT&gt;(nativeAddresses[i]));&#xD;
              addressesArray-&gt;addValue(item);&#xD;
            }&#xD;
        }&#xD;
      }&#xD;
      res.reset(new Numeric&lt;EncodingT&gt;(hr));&#xD;
		}&#xD;
	}&#xD;
	return res;&#xD;
</Content>
    </File>
    <File Name="ImageFileMachine">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="DebugBreakpoint">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="DebugBreakpointFlag">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
    <File Name="IDebugBreakpointPtr">
      <Entity Class="Data" Name="IDebugBreakpointPtr">
        <Attribute Modifier="Virtual " Name="Id" Type="Any"/>
      </Entity>
      <Content Type="Global-inclusion">&#xD;
#include "DebugPtr.h"&#xD;
typedef IDebugBreakpoint* IDebugBreakpointPtr;&#xD;
</Content>
    </File>
    <File Name="DEBUG_STACK_FRAME">
      <Content Type="Global-inclusion">&#xD;
</Content>    </File>
  </Workspace>

</document_schema>
