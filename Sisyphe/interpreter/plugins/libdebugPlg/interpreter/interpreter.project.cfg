///////////////////////////////////////////////////////////////////////////////
// Workspace
///////////////////////////////////////////////////////////////////////////////

Author = Teddy DIDE; 
Brief = Debug Interpreter generated by gensources.;
Name = Debug_interpreter;
Option = 0;
Type = Project;
Version = 1.00;

///////////////////////////////////////////////////////////////////////////////
// DebugEngine
///////////////////////////////////////////////////////////////////////////////

file[DebugEngine]

./content[Global-inclusion] = ${
#include "IDebugClientPtrInterpreter.hpp"
#include "IDebugControlPtrInterpreter.hpp"
#include "IDebugSystemObjectsPtrInterpreter.hpp"
#include "IDebugSymbolsPtrInterpreter.hpp"
#include "IDebugBreakpointPtrInterpreter.hpp"

NAMESPACE_BEGIN(interp)
  template <class EncodingT>
  class DebugEngineInterpreter;
NAMESPACE_END

template <class EncodingT>
class EventCallbacks : public DebugBaseEventCallbacks   // event callback class has 16 methods
{
private:
  interp::DebugEngineInterpreter<EncodingT> *m_Owner;
  CDebugPtr<IDebugControl3>  m_Control;
  IDebugBreakpoint* m_Breakpoint;

public:
       EventCallbacks(interp::DebugEngineInterpreter<EncodingT> *owner, IDebugControl3 *control);
       ~EventCallbacks();
       STDMETHOD_(ULONG, AddRef)         ( THIS );
       STDMETHOD_(ULONG, Release)        ( THIS );
       STDMETHOD(Breakpoint)             ( THIS_ IN PDEBUG_BREAKPOINT Bp );
       STDMETHOD(ChangeDebuggeeState)    ( THIS_ IN ULONG Flags, IN ULONG64  Argument );
       STDMETHOD(ChangeEngineState)      ( THIS_ IN ULONG Flags, IN ULONG64  Argument );
       STDMETHOD(ChangeSymbolState)      ( THIS_ IN ULONG Flags, IN ULONG64  Argument );
       STDMETHOD(CreateThread)           ( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset,IN ULONG64  StartOffset);
       STDMETHOD(Exception)              ( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance );
       STDMETHOD(ExitProcess)            ( THIS_ IN ULONG  ExitCode );
       STDMETHOD(ExitThread)             ( THIS_ IN ULONG  ExitCode );
       STDMETHOD(GetInterestMask)        ( THIS_ OUT PULONG Mask );
       STDMETHOD(SessionStatus)          ( THIS_ IN ULONG Status );
       STDMETHOD(SystemError)            ( THIS_ IN ULONG  Error, IN ULONG  Level );
       STDMETHOD(UnloadModule)           ( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset );
       STDMETHOD(LoadModule)             (  THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,
                                          IN ULONG ModuleSize,  IN PCSTR ModuleName,IN PCSTR ImageName,  IN ULONG CheckSum,
                                          IN ULONG TimeDateStamp );
       STDMETHOD(CreateProcess)          ( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle, IN ULONG64 BaseOffset, IN ULONG ModuleSize, 
                                          IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum,
                                          IN ULONG TimeDateStamp,  IN ULONG64 InitialThreadHandle,   IN ULONG64 ThreadDataOffset,
                                          IN ULONG64 StartOffset );
};
}$

./content[Global-body] = ${
template <class EncodingT>
EventCallbacks<EncodingT>::EventCallbacks(interp::DebugEngineInterpreter<EncodingT> *owner, IDebugControl3 *control)
: m_Owner(owner), m_Control(control), m_Breakpoint(NULL)
{
}

template <class EncodingT>
EventCallbacks<EncodingT>::~EventCallbacks()
{
      if (m_Control && m_Breakpoint)
      {
            HRESULT status = m_Control->RemoveBreakpoint(m_Breakpoint);
            if (status == S_OK)
            {
                   m_Breakpoint = NULL;
            }
       }
}

template <class EncodingT>
STDMETHODIMP_(ULONG) EventCallbacks<EncodingT>::AddRef( THIS )  // event callback method 1
{
       return 1;
}
template <class EncodingT>
STDMETHODIMP_(ULONG) EventCallbacks<EncodingT>::Release( THIS )  //event callback method 2
{
       return 0;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::Breakpoint( THIS_ IN PDEBUG_BREAKPOINT Bp ) //event callback method 3
{
       if (m_Owner != NULL) 
       {
            m_Owner->AddTriggeredBreakpoint(Bp);
       }
       return DEBUG_STATUS_BREAK;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::CreateProcess(THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle,
       IN ULONG64 BaseOffset,IN ULONG ModuleSize,IN PCSTR ModuleName,IN PCSTR ImageName,
       IN ULONG CheckSum, IN ULONG TimeDateStamp,IN ULONG64 InitialThreadHandle,
       IN ULONG64 ThreadDataOffset,  IN ULONG64 StartOffset
       ) //event callback method 4  and so on till method 16
{
       if (m_Control)
       {
             HRESULT status = 0; //we are setting a break point in Address Of Entrypoint of the debuggee
             IDebugBreakpoint* breakpoint = NULL;
             if ((status = m_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE,DEBUG_ANY_ID, &breakpoint)) == S_OK)
             {
                    if (( status = breakpoint->SetOffset(StartOffset)) == S_OK)
                    {
                           if (( status = breakpoint->SetFlags(DEBUG_BREAKPOINT_ENABLED)) == S_OK)
                           {
                                  m_Breakpoint = breakpoint;
                           }
                    }
             }
       }
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::CreateThread( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset, IN ULONG64  StartOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::Exception( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance )
{
       HRESULT hres = DEBUG_STATUS_BREAK;
       if (Exception != NULL && Exception->ExceptionCode == 0x406D1388)
       {
               hres = DEBUG_STATUS_NO_CHANGE;
       }
       return hres;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ExitProcess (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ExitThread (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::GetInterestMask( THIS_ OUT PULONG Mask )
{
       *Mask =
              DEBUG_EVENT_BREAKPOINT |
              DEBUG_EVENT_EXCEPTION |
              DEBUG_EVENT_CREATE_THREAD |
              DEBUG_EVENT_EXIT_THREAD |
              DEBUG_EVENT_CREATE_PROCESS |
              DEBUG_EVENT_EXIT_PROCESS |
              DEBUG_EVENT_LOAD_MODULE |
              DEBUG_EVENT_UNLOAD_MODULE |
              DEBUG_EVENT_SYSTEM_ERROR |
              DEBUG_EVENT_SESSION_STATUS |
              DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
              DEBUG_EVENT_CHANGE_ENGINE_STATE |
              DEBUG_EVENT_CHANGE_SYMBOL_STATE;
       return S_OK;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::LoadModule( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,
       IN ULONG ModuleSize,IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum, IN ULONG TimeDateStamp )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::SystemError( THIS_ IN ULONG  Error, IN ULONG  Level )
{
       return DEBUG_STATUS_BREAK;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::UnloadModule( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::SessionStatus( THIS_ IN ULONG SessionStatus )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ChangeDebuggeeState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ChangeEngineState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       if ((m_Owner != NULL) && (DEBUG_CES_EXECUTION_STATUS == Flags) && 
           (DEBUG_STATUS_BREAK != Argument) && (DEBUG_STATUS_NO_CHANGE != Argument) && (DEBUG_STATUS_NO_DEBUGGEE != Argument))
       {
              m_Owner->ResetTriggeredBreakpoint();  
       }
       return DEBUG_STATUS_NO_CHANGE;
}
template <class EncodingT>
STDMETHODIMP EventCallbacks<EncodingT>::ChangeSymbolState( THIS_ IN ULONG Flags, IN ULONG64 Argument ) // method 16
{
       return DEBUG_STATUS_NO_CHANGE;
}
}$

./content[Declaration] = ${
private:
  IDebugClient *m_debugClient;
  EventCallbacks<EncodingT> *m_eventCallback;
  IDebugControl3 *m_debugControl;
  IDebugSystemObjects *m_debugSystemObjects;
  IDebugSymbols *m_debugSymbols;
  std::vector<IDebugBreakpoint *> m_triggeredBreakpoints;
  
public:
  // Retourne l'objet DebugClient
  boost::shared_ptr< Base<EncodingT> > getDebugClient() const;
  
  // Retourne l'objet DebugControl
  boost::shared_ptr< Base<EncodingT> > getDebugControl() const;
  
  // Retourne l'objet DebugSystemObjects
  boost::shared_ptr< Base<EncodingT> > getDebugSystemObjects() const;
  
  // Retourne l'objet DebugSymbols
  boost::shared_ptr< Base<EncodingT> > getDebugSymbols() const;

  // Ajoute l'objet DebugBreakpoint
  void AddTriggeredBreakpoint(IDebugBreakpoint* const breakpoint);
  
  // Réinitialise l'objet DebugBreakpoint
  void ResetTriggeredBreakpoint();
  
  // Retourne le nombre d'objet DebugBreakpoint
  boost::shared_ptr< Base<EncodingT> > getTriggeredBreakpointsCount() const;
  
  // Retourne l'objet DebugBreakpoint
  FACTORY_PROTOTYPE1(getTriggeredBreakpoint, In< boost::shared_ptr< Base<EncodingT> > >)
  boost::shared_ptr< Base<EncodingT> > getTriggeredBreakpoint(const boost::shared_ptr< Base<EncodingT> >& i) const;
}$

./content[Implementation] = ${
  // Retourne l'objet DebugClient
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugClient() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugClientPtrInterpreter<EncodingT>(IDebugClientPtr(m_debugClient)));
  }
  
  // Retourne l'objet DebugControl
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugControl() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugControlPtrInterpreter<EncodingT>(IDebugControlPtr(m_debugControl)));
  }
  
  // Retourne l'objet DebugSystemObjects
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSystemObjects() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugSystemObjectsPtrInterpreter<EncodingT>(IDebugSystemObjectsPtr(m_debugSystemObjects)));
  }
 
  // Retourne l'objet DebugSymbols
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSymbols() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new IDebugSymbolsPtrInterpreter<EncodingT>(IDebugSymbolsPtr(m_debugSymbols)));
  }
  
  // Ajoute l'objet TriggeredBreakpoint
  template <class EncodingT>
  void DebugEngineInterpreter<EncodingT>::AddTriggeredBreakpoint(IDebugBreakpoint* const breakpoint)
  {
    m_triggeredBreakpoints.push_back(breakpoint);
  }
  
  // Réinitialise l'objet DebugBreakpoint
  template <class EncodingT>
  void DebugEngineInterpreter<EncodingT>::ResetTriggeredBreakpoint()
  {
    m_triggeredBreakpoints.clear();
  }
  
  // Retourne le nombre d'objet DebugBreakpoint
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getTriggeredBreakpointsCount() const
  {
    return boost::shared_ptr< Base<EncodingT> > (new Numeric<EncodingT>(m_triggeredBreakpoints.size()));
  }
  
  // Retourne l'objet TriggeredBreakpoint
  template <class EncodingT>
  boost::shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getTriggeredBreakpoint(const boost::shared_ptr< Base<EncodingT> >& i) const
  {
    IDebugBreakpoint * bp = NULL;
    size_t index = 0;
    if (check_numeric_i(i, index))
    {
        if (check_index(index, m_triggeredBreakpoints.size()))
        {
            bp = m_triggeredBreakpoints[index];
        }
    }
    return boost::shared_ptr< Base<EncodingT> > (new IDebugBreakpointPtrInterpreter<EncodingT>(bp));
  }
}$

./content[Register] = ${
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr< Base<EncodingT> >, getDebugClient, const_t, C("DebugEngine::DebugClient") );
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr< Base<EncodingT> >, getDebugControl, const_t, C("DebugEngine::DebugControl") );
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr< Base<EncodingT> >, getDebugSystemObjects, const_t, C("DebugEngine::DebugSystemObjects") );
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr< Base<EncodingT> >, getDebugSymbols, const_t, C("DebugEngine::DebugSymbols") );
METHOD_KEY_REGISTER ( DebugEngineInterpreter, boost::shared_ptr< Base<EncodingT> >, getTriggeredBreakpointsCount, const_t, C("DebugEngine::TriggeredBreakpointsCount") );
METHOD_KEY_REGISTER1( DebugEngineInterpreter, boost::shared_ptr< Base<EncodingT> >, getTriggeredBreakpoint, const_t, C("DebugEngine::GetTriggeredBreakpoint") );
}$

./content[Unregister] = ${
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugClient") );
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugControl") );
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugSystemObjects") );
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugSymbols") );
METHOD_KEY_UNREGISTER ( C("DebugEngine::TriggeredBreakpointsCount") );
METHOD_KEY_UNREGISTER1( C("DebugEngine::GetTriggeredBreakpoint") );
}$

./content[Initialization-body] = ${
  m_debugClient = NULL;
  m_eventCallback = NULL;
  m_debugControl = NULL;
  m_debugSystemObjects = NULL;
  m_debugSymbols = NULL;
}$

./content[Destruction-body] = ${
  terminate();
}$

./content[Boolean DebugEngine::initialize()][Implementation-body] = ${
  if (m_debugClient == NULL)
  {
    HRESULT hr = DebugCreate(IID_IDebugClient, (void**)&m_debugClient);
    if(SUCCEEDED(hr))
    {  
        hr = m_debugClient->QueryInterface(IID_IDebugControl3, (void**)&m_debugControl);
        if (SUCCEEDED(hr))
        {
            m_eventCallback = new EventCallbacks<EncodingT>(this, m_debugControl);
            hr = m_debugClient->SetEventCallbacks(m_eventCallback);
        }
        hr = m_debugClient->QueryInterface(IID_IDebugSystemObjects, (void**)&m_debugSystemObjects);
        hr = m_debugClient->QueryInterface(IID_IDebugSymbols, (void**)&m_debugSymbols);
    }
  }
  return boost::shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient != NULL));
}$

./content[Boolean DebugEngine::terminate()][Implementation-body] = ${
  m_triggeredBreakpoints.clear();
  if(m_debugSymbols != NULL)
  {
    m_debugSymbols->Release();
    m_debugSymbols = NULL;
  }
  if(m_debugSystemObjects != NULL)
  {
    m_debugSystemObjects->Release();
    m_debugSystemObjects = NULL;
  }
  if (m_eventCallback != NULL)
  {
    delete m_eventCallback;
    m_eventCallback = NULL;
  }
  if(m_debugControl != NULL)
  {
    m_debugControl->Release();
    m_debugControl = NULL;
  }
  if(m_debugClient != NULL)
  {
    m_debugClient->EndSession(DEBUG_END_PASSIVE);
    m_debugClient->Release();
    m_debugClient = NULL;
  }
  return boost::shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient == NULL));
}$

./content[Int DebugEngine::DvAlloc(Uint32)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  if (m_debugSystemObjects != NULL)
  {
    unsigned long nativeSize;
    if (check_numeric_i(size, nativeSize))
    {
      unsigned long long hProcess;
      HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
      if (SUCCEEDED(hr))
      {
        res.reset(new Numeric<EncodingT>((unsigned long long) VirtualAllocEx((HANDLE) hProcess, NULL, nativeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)));
      }
    }
  }
  return res;
}$

./content[Boolean DebugEngine::DvFree(Int,Uint32)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Bool<EncodingT>(false));
  if (m_debugSystemObjects != NULL)
  {
    unsigned long nativeSize;
    int nativeBaseAddress;
    if (check_numeric_i(baseAddress, nativeBaseAddress) && check_numeric_i(size, nativeSize))
    {
      unsigned long long hProcess;
      HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
      if (SUCCEEDED(hr))
      {
          res.reset(new Bool<EncodingT>(VirtualFreeEx((HANDLE) hProcess, (LPVOID)nativeBaseAddress, nativeSize, MEM_RELEASE)));
      }
    }
  }
  return res;
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugClientPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugClientPtr]

./entity[IDebugClientPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugClient> IDebugClientPtr;
#include "IDebugControlPtrInterpreter.hpp"
}$

./content[Int32 IDebugClientPtr::CreateProcess(AnsiString,Uint32)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugClientPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    typename EncodingT::string_t nativeCommandLine;
    unsigned long nativeCreateFlags;
    if (check_string<EncodingT>(commandLine, nativeCommandLine) && 
        check_numeric_i(createFlags, nativeCreateFlags))
    {
          char ansiCommandLine[MAX_PATH];
          std::copy(nativeCommandLine.begin(), nativeCommandLine.end(), ansiCommandLine);
          res.reset(new Numeric<EncodingT>(valuePtr->CreateProcess(0, ansiCommandLine, nativeCreateFlags)));
    }
  }
  return res;
}$

./content[Int32 IDebugClientPtr::CreateProcess(AnsiString,Uint32,AnsiString)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugClientPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    typename EncodingT::string_t nativeCommandLine;
    typename EncodingT::string_t nativeInitialDirectory;
    unsigned long nativeCreateFlags;
    if (check_string<EncodingT>(commandLine, nativeCommandLine) && 
        check_string<EncodingT>(initialDirectory, nativeInitialDirectory) && 
        check_numeric_i(createFlags, nativeCreateFlags))
    {
          TCHAR cwd[MAX_PATH];
          // Retrieves the current directory for the current process.
          GetCurrentDirectory(MAX_PATH, cwd);

          // Changes the current directory for the current process.
          SetCurrentDirectory(nativeInitialDirectory.c_str());

          char ansiCommandLine[MAX_PATH];
          std::copy(nativeCommandLine.begin(), nativeCommandLine.end(), ansiCommandLine);
          res.reset(new Numeric<EncodingT>(valuePtr->CreateProcess(0, ansiCommandLine, nativeCreateFlags)));
          
          // Reset the current directory
          SetCurrentDirectory(cwd);
    }
  }
  return res;
}$

./content[Int32 IDebugClientPtr::GetRunningProcessSystemIds(Uint32*)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugClientPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    unsigned long nativeId, nativeActualCount;
    res.reset(new Numeric<EncodingT>(valuePtr->GetRunningProcessSystemIds(0, &nativeId, 1, &nativeActualCount)));
    reset_numeric_i(processId, nativeId);
  }
  return res;
}$

./content[Int32 IDebugClientPtr::GetRunningProcessDescription(Uint32,Uint32,AnsiString,AnsiString)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugClientPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    unsigned long nativeSystemId;
    unsigned long nativeFlags;
    if (check_numeric_i(systemId, nativeSystemId) && 
        check_numeric_i(flags, nativeFlags))
    {
      char ansiNativeExeName[MAX_PATH];
      char ansiNativeDescription[MAX_PATH];
      unsigned long nativeActualExeNameSize, nativeActualDescriptionSize;
      res.reset(new Numeric<EncodingT>(valuePtr->GetRunningProcessDescription(0, nativeSystemId, nativeFlags, ansiNativeExeName, MAX_PATH, &nativeActualExeNameSize, ansiNativeDescription, MAX_PATH, &nativeActualDescriptionSize)));
      reset_string<ansi>(exeName, ansiNativeExeName);
      reset_string<ansi>(description, ansiNativeDescription);
    }
  }
  return res;
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugControlPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugControlPtr]

./entity[IDebugControlPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugControl3> IDebugControlPtr;
#include "IDebugBreakpointPtrInterpreter.hpp"
#include "DEBUG_STACK_FRAMEInterpreter.hpp"
}$

./content[Int32 IDebugControlPtr::GetPromptText(AnsiString)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugControlPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    char nativeBuffer[2048];
    res.reset(new Numeric<EncodingT>(valuePtr->GetPromptText(nativeBuffer, 2048, NULL)));
    reset_string<ansi>(buffer, nativeBuffer);
  }
  return res;
}$

./content[Int32 IDebugControlPtr::GetStackTrace(UInt64,UInt64,UInt64,DEBUG_STACK_FRAME,UInt32,UInt32*)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugControlPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    unsigned long long nativeFrameOffset;
    unsigned long long nativeStackOffset;
    unsigned long long nativeInstructionOffset;
    std::vector< DEBUG_STACK_FRAME > nativeFrames;
    unsigned long nativeFrameSize;
    unsigned long nativeFramesFilled;
    if (check_numeric_i(frameOffset, nativeFrameOffset) &&
      check_numeric_i(stackOffset, nativeStackOffset) &&
      check_numeric_i(instructionOffset, nativeInstructionOffset) &&
      check_array(frames, nativeFrames, check_DEBUG_STACK_FRAME<EncodingT>) &&
      check_numeric_i(frameSize, nativeFrameSize) &&
      check_numeric_i(framesFilled, nativeFramesFilled))
    {
      nativeFrames.resize(nativeFrameSize);
      res.reset(new Numeric<EncodingT>(valuePtr->GetStackTrace(nativeFrameOffset, nativeStackOffset, nativeInstructionOffset, nativeFrames.data(), nativeFrameSize, &nativeFramesFilled)));
      boost::shared_ptr< Array<EncodingT> > framesArray  = dynamic_pointer_cast< Array<EncodingT> >(frames);
      if (framesArray)
      {
          for (size_t i = 0; i < nativeFramesFilled; ++i)
          {
            boost::shared_ptr< Base<EncodingT> > item(new DEBUG_STACK_FRAMEInterpreter<EncodingT>(nativeFrames[i]));
            framesArray->addValue(item);
          }
      }
      reset_numeric_i(framesFilled, nativeFramesFilled);
    }
  }
  return res;
}$

///////////////////////////////////////////////////////////////////////////////
// DebugStatus
///////////////////////////////////////////////////////////////////////////////

file[DebugStatus]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// CreateFlags
///////////////////////////////////////////////////////////////////////////////

file[CreateFlags]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// WaitFlags
///////////////////////////////////////////////////////////////////////////////

file[WaitFlags]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// TimeOut
///////////////////////////////////////////////////////////////////////////////

file[TimeOut]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DEBUG_VALUE
///////////////////////////////////////////////////////////////////////////////

file[DEBUG_VALUE]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugValue
///////////////////////////////////////////////////////////////////////////////

file[DebugValue]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugExecute
///////////////////////////////////////////////////////////////////////////////

file[DebugExecute]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugOutCTL
///////////////////////////////////////////////////////////////////////////////

file[DebugOutCTL]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugSystemObjectsPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugSystemObjectsPtr]

./entity[IDebugSystemObjectsPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugSystemObjects> IDebugSystemObjectsPtr;
}$

./content[Int32 IDebugSystemObjectsPtr::GetCurrentProcessExecutableName(AnsiString)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugSystemObjectsPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    char nativeBuffer[MAX_PATH];
    res.reset(new Numeric<EncodingT>(valuePtr->GetCurrentProcessExecutableName(nativeBuffer, MAX_PATH, NULL)));
    reset_string<ansi>(buffer, nativeBuffer);
  }
  return res;
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugSymbolsPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugSymbolsPtr]

./entity[IDebugSymbolsPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugSymbols> IDebugSymbolsPtr;
}$

./content[Int32 IDebugSymbolsPtr::GetSymbolPath(AnsiString)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugSymbolsPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    char nativeBuffer[2048];
    ZeroMemory(nativeBuffer, 2048);
    res.reset(new Numeric<EncodingT>(valuePtr->GetSymbolPath(nativeBuffer, 2048, NULL)));
    reset_string<ansi>(buffer, nativeBuffer);
  }
  return res;
}$

./content[Int32 IDebugSymbolsPtr::GetLineByOffset(UInt64,UInt32*,AnsiString,UInt64*)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugSymbolsPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    unsigned long long nativeOffset;
    unsigned long nativeLine;
    char nativeFileBuffer[2048];
    ZeroMemory(nativeFileBuffer, 2048);
    unsigned long long nativeDisplacement;
    if (check_numeric_i(offset, nativeOffset) && 
        check_numeric_i(line, nativeLine) &&
        check_numeric_i(displacement, nativeDisplacement))
    {
      res.reset(new Numeric<EncodingT>(valuePtr->GetLineByOffset(nativeOffset, &nativeLine, nativeFileBuffer, 2048, NULL, &nativeDisplacement)));
      reset_numeric_i(line, nativeLine);
      reset_string<ansi>(fileBuffer, nativeFileBuffer);
      reset_numeric_i(displacement, nativeDisplacement);
    }
  }
  return res;
}$

./content[Int32 IDebugSymbolsPtr::GetNameByOffset(UInt64,AnsiString,UInt64*)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugSymbolsPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    unsigned long long nativeOffset;
    char nativeNameBuffer[2048];
    ZeroMemory(nativeNameBuffer, 2048);
    unsigned long long nativeDisplacement;
    if (check_numeric_i(offset, nativeOffset) &&
        check_numeric_i(displacement, nativeDisplacement))
    {
      res.reset(new Numeric<EncodingT>(valuePtr->GetNameByOffset(nativeOffset, nativeNameBuffer, 2048, NULL, &nativeDisplacement)));
      reset_string<ansi>(nameBuffer, nativeNameBuffer);
      reset_numeric_i(displacement, nativeDisplacement);
    }
  }
  return res;
}$

./content[Int32 IDebugSymbolsPtr::GetNearNameByOffset(UInt64,Int32,AnsiString,UInt64*)][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDebugSymbolsPtr valuePtr = value();
  if (valuePtr != NULL)
  {
    unsigned long long nativeOffset;
    long nativeDelta;
    char nativeNameBuffer[2048];
    ZeroMemory(nativeNameBuffer, 2048);
    unsigned long long nativeDisplacement;
    if (check_numeric_i(offset, nativeOffset) && 
        check_numeric_i(delta, nativeDelta) &&
        check_numeric_i(displacement, nativeDisplacement))
    {
      res.reset(new Numeric<EncodingT>(valuePtr->GetNearNameByOffset(nativeOffset, nativeDelta, nativeNameBuffer, 2048, NULL, &nativeDisplacement)));
      reset_string<ansi>(nameBuffer, nativeNameBuffer);
      reset_numeric_i(displacement, nativeDisplacement);
    }
  }
  return res;
}$

./content[Int32 IDebugSymbolsPtr::GetSourceFileLineOffsets(AnsiString,UInt64)][Implementation-body] = ${
	boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	IDebugSymbolsPtr valuePtr = value();
	if (valuePtr != NULL)
	{
		typename ansi::string_t nativeFile;
    std::vector< unsigned long long > nativeAddresses;
		if (check_string<ansi>(file, nativeFile) &&
        check_array(addresses, nativeAddresses, check_numeric_i<EncodingT,unsigned long long>))
		{
      unsigned long nlines = 0;
      HRESULT hr = valuePtr->GetSourceFileLineOffsets(nativeFile.c_str(), NULL, 0, &nlines);
      if (SUCCEEDED(hr))
      {
        nativeAddresses.resize(nlines);
        hr = valuePtr->GetSourceFileLineOffsets(nativeFile.c_str(), nativeAddresses.data(), nlines, NULL);
        boost::shared_ptr< Array<EncodingT> > addressesArray  = dynamic_pointer_cast< Array<EncodingT> >(addresses);
        if (addressesArray)
        {
            for (size_t i = 0; i < nlines; ++i)
            {
              boost::shared_ptr< Base<EncodingT> > item(new Numeric<EncodingT>(nativeAddresses[i]));
              addressesArray->addValue(item);
            }
        }
      }
      res.reset(new Numeric<EncodingT>(hr));
		}
	}
	return res;
}$

///////////////////////////////////////////////////////////////////////////////
// ImageFileMachine
///////////////////////////////////////////////////////////////////////////////

file[ImageFileMachine]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugBreakpoint
///////////////////////////////////////////////////////////////////////////////

file[DebugBreakpoint]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugBreakpointFlag
///////////////////////////////////////////////////////////////////////////////

file[DebugBreakpointFlag]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugBreakpointPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugBreakpointPtr]

./entity[IDebugBreakpointPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef IDebugBreakpoint* IDebugBreakpointPtr;
}$

///////////////////////////////////////////////////////////////////////////////
// DEBUG_VALUE
///////////////////////////////////////////////////////////////////////////////

file[DEBUG_VALUE]

./content[SByte DEBUG_VALUE::I8][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((char) value().I8));
  return res;
}$

./content[Int16 DEBUG_VALUE::I16][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((short) value().I16));
  return res;
}$

./content[Int32 DEBUG_VALUE::I32][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((int) value().I32));
  return res;
}$

./content[Int64 DEBUG_VALUE::I64][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((long long) value().I64));
  return res;
}$

./content[Byte DEBUG_VALUE::UI8][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((unsigned char) value().I8));
  return res;
}$

./content[UInt16 DEBUG_VALUE::UI16][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((unsigned short) value().I16));
  return res;
}$

./content[UInt32 DEBUG_VALUE::UI32][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((unsigned int) value().I32));
  return res;
}$

./content[UInt64 DEBUG_VALUE::UI64][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>((unsigned long long) value().I64));
  return res;
}$

./content[AnsiChar DEBUG_VALUE::C8][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new String<EncodingT>((char) value().I8));
  return res;
}$

./content[WideChar DEBUG_VALUE::C16][Implementation-body] = ${
  boost::shared_ptr< Base<EncodingT> > res(new String<EncodingT>((wchar_t) value().I16));
  return res;
}$

///////////////////////////////////////////////////////////////////////////////
// DEBUG_STACK_FRAME
///////////////////////////////////////////////////////////////////////////////

file[DEBUG_STACK_FRAME]
./content[Global-inclusion] = ${
}$
