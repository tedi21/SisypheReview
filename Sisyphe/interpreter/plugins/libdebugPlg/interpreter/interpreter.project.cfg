///////////////////////////////////////////////////////////////////////////////
// Workspace
///////////////////////////////////////////////////////////////////////////////

Author = Teddy DIDE; 
Brief = Debug Interpreter generated by gensources.;
Name = Debug_interpreter;
Option = 0;
Type = Project;
Version = 1.00;

///////////////////////////////////////////////////////////////////////////////
// DebugEngine
///////////////////////////////////////////////////////////////////////////////

file[DebugEngine]

./content[Global-inclusion] = ${
#include "IDebugClientPtrInterpreter.hpp"
#include "IDebugControlPtrInterpreter.hpp"
#include "IDebugSystemObjectsPtrInterpreter.hpp"
#include "IDebugSymbolsPtrInterpreter.hpp"

class EventCallbacks : public DebugBaseEventCallbacks   // event callback class has 16 methods
{
private:
  CDebugPtr<IDebugControl3>  m_Control;
  CDebugPtr<IDebugBreakpoint> m_Breakpoint;

public:
       EventCallbacks(IDebugControl3 *control);
       STDMETHOD_(ULONG, AddRef)         ( THIS );
       STDMETHOD_(ULONG, Release)        ( THIS );
       STDMETHOD(Breakpoint)             ( THIS_ IN PDEBUG_BREAKPOINT Bp );
       STDMETHOD(ChangeDebuggeeState)    ( THIS_ IN ULONG Flags, IN ULONG64  Argument );
       STDMETHOD(ChangeEngineState)      ( THIS_ IN ULONG Flags, IN ULONG64  Argument );
       STDMETHOD(ChangeSymbolState)      ( THIS_ IN ULONG Flags, IN ULONG64  Argument );
       STDMETHOD(CreateThread)           ( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset,IN ULONG64  StartOffset);
       STDMETHOD(Exception)              ( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance );
       STDMETHOD(ExitProcess)            ( THIS_ IN ULONG  ExitCode );
       STDMETHOD(ExitThread)             ( THIS_ IN ULONG  ExitCode );
       STDMETHOD(GetInterestMask)        ( THIS_ OUT PULONG Mask );
       STDMETHOD(SessionStatus)          ( THIS_ IN ULONG Status );
       STDMETHOD(SystemError)            ( THIS_ IN ULONG  Error, IN ULONG  Level );
       STDMETHOD(UnloadModule)           ( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset );
       STDMETHOD(LoadModule)             (  THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,
                                          IN ULONG ModuleSize,  IN PCSTR ModuleName,IN PCSTR ImageName,  IN ULONG CheckSum,
                                          IN ULONG TimeDateStamp );
       STDMETHOD(CreateProcess)          ( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle, IN ULONG64 BaseOffset, IN ULONG ModuleSize, 
                                          IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum,
                                          IN ULONG TimeDateStamp,  IN ULONG64 InitialThreadHandle,   IN ULONG64 ThreadDataOffset,
                                          IN ULONG64 StartOffset );
};
}$

./content[Global-body] = ${
template <class EncodingT>
IDebugClient* interp::DebugEngineInterpreter<EncodingT>::m_debugClient = NULL;
template <class EncodingT>
IDebugControl3* interp::DebugEngineInterpreter<EncodingT>::m_debugControl = NULL;
template <class EncodingT>
EventCallbacks* interp::DebugEngineInterpreter<EncodingT>::m_eventCallback = NULL;
template <class EncodingT>
IDebugSystemObjects* interp::DebugEngineInterpreter<EncodingT>::m_debugSystemObjects = NULL;
template <class EncodingT>
IDebugSymbols* interp::DebugEngineInterpreter<EncodingT>::m_debugSymbols = NULL;

EventCallbacks::EventCallbacks(IDebugControl3 *control)
: m_Control(control)
{
}

STDMETHODIMP_(ULONG) EventCallbacks::AddRef(    THIS )  // event callback method 1
{
       return 1;
}
STDMETHODIMP_(ULONG) EventCallbacks::Release( THIS )  //event callback method 2
{
       return 0;
}
STDMETHODIMP EventCallbacks::Breakpoint( THIS_ IN PDEBUG_BREAKPOINT Bp ) //event callback method 3
{
       return DEBUG_STATUS_BREAK;
}
STDMETHODIMP EventCallbacks::CreateProcess(THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle,
       IN ULONG64 BaseOffset,IN ULONG ModuleSize,IN PCSTR ModuleName,IN PCSTR ImageName,
       IN ULONG CheckSum, IN ULONG TimeDateStamp,IN ULONG64 InitialThreadHandle,
       IN ULONG64 ThreadDataOffset,  IN ULONG64 StartOffset
       ) //event callback method 4  and so on till method 16
{
       HRESULT status = 0; //we are setting a break point in Address Of Entrypoint of the debuggee
       IDebugBreakpoint* breakpoint = NULL;
       if (( status = m_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE,DEBUG_ANY_ID, &breakpoint)) == S_OK)
       {
              if (( status = breakpoint->SetOffset(StartOffset)) == S_OK)
              {
                     if (( status = breakpoint->SetFlags(DEBUG_BREAKPOINT_ENABLED)) == S_OK)
                     {
                            m_Breakpoint.reset(breakpoint);
                            breakpoint->Release();
                     }
              }
       }
       return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP EventCallbacks::CreateThread( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset, IN ULONG64  StartOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::Exception( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance )
{
       return DEBUG_STATUS_BREAK;
}
STDMETHODIMP EventCallbacks::ExitProcess (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ExitThread (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::GetInterestMask( THIS_ OUT PULONG Mask )
{
       *Mask =
              DEBUG_EVENT_BREAKPOINT |
              DEBUG_EVENT_EXCEPTION |
              DEBUG_EVENT_CREATE_THREAD |
              DEBUG_EVENT_EXIT_THREAD |
              DEBUG_EVENT_CREATE_PROCESS |
              DEBUG_EVENT_EXIT_PROCESS |
              DEBUG_EVENT_LOAD_MODULE |
              DEBUG_EVENT_UNLOAD_MODULE |
              DEBUG_EVENT_SYSTEM_ERROR |
              DEBUG_EVENT_SESSION_STATUS |
              DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
              DEBUG_EVENT_CHANGE_ENGINE_STATE |
              DEBUG_EVENT_CHANGE_SYMBOL_STATE;
       return S_OK;
}
STDMETHODIMP EventCallbacks::LoadModule( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,
       IN ULONG ModuleSize,IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum, IN ULONG TimeDateStamp )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::SystemError( THIS_ IN ULONG  Error, IN ULONG  Level )
{
       return DEBUG_STATUS_BREAK;
}
STDMETHODIMP EventCallbacks::UnloadModule( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::SessionStatus( THIS_ IN ULONG SessionStatus )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ChangeDebuggeeState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ChangeEngineState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ChangeSymbolState( THIS_ IN ULONG Flags, IN ULONG64 Argument ) // method 16
{
       return DEBUG_STATUS_NO_CHANGE;
}
}$

./content[Declaration] = ${
private:
  static IDebugClient *m_debugClient;
  static EventCallbacks *m_eventCallback;
  static IDebugControl3 *m_debugControl;
  static IDebugSystemObjects* m_debugSystemObjects;
  static IDebugSymbols* m_debugSymbols;
  
public:
  // Retourne l'objet DebugClient
  shared_ptr< Base<EncodingT> > getDebugClient() const;
  
  // Retourne l'objet DebugControl
  shared_ptr< Base<EncodingT> > getDebugControl() const;
  
  // Retourne l'objet DebugSystemObjects
  shared_ptr< Base<EncodingT> > getDebugSystemObjects() const;
  
  // Retourne l'objet DebugSymbols
  shared_ptr< Base<EncodingT> > getDebugSymbols() const;
}$

./content[Implementation] = ${
  // Retourne l'objet DebugClient
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugClient() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugClientPtrInterpreter<EncodingT>(m_debugClient));
  }
  
  // Retourne l'objet DebugControl
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugControl() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugControlPtrInterpreter<EncodingT>(m_debugControl));
  }
  
  // Retourne l'objet DebugSystemObjects
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSystemObjects() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugSystemObjectsPtrInterpreter<EncodingT>(m_debugSystemObjects));
  }
 
  // Retourne l'objet DebugSymbols
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSymbols() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugSymbolsPtrInterpreter<EncodingT>(m_debugSymbols));
  }
}$

./content[Register] = ${
METHOD_KEY_REGISTER ( DebugEngineInterpreter, shared_ptr< Base<EncodingT> >, getDebugClient, const_t, C("DebugEngine::DebugClient") );
METHOD_KEY_REGISTER ( DebugEngineInterpreter, shared_ptr< Base<EncodingT> >, getDebugControl, const_t, C("DebugEngine::DebugControl") );
METHOD_KEY_REGISTER ( DebugEngineInterpreter, shared_ptr< Base<EncodingT> >, getDebugSystemObjects, const_t, C("DebugEngine::DebugSystemObjects") );
METHOD_KEY_REGISTER ( DebugEngineInterpreter, shared_ptr< Base<EncodingT> >, getDebugSymbols, const_t, C("DebugEngine::DebugSymbols") );
}$

./content[Unregister] = ${
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugClient") );
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugControl") );
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugSystemObjects") );
METHOD_KEY_UNREGISTER ( C("DebugEngine::DebugSymbols") );
}$

./content[Boolean DebugEngine::initialize()][Implementation-body] = ${
  if (m_debugClient == NULL)
  {
    HRESULT hr = DebugCreate(IID_IDebugClient, (void**)&m_debugClient);
    if(SUCCEEDED(hr))
    {  
        hr = m_debugClient->QueryInterface(IID_IDebugControl3, (void**)&m_debugControl);
        if (SUCCEEDED(hr))
        {
            m_eventCallback = new EventCallbacks(m_debugControl);
            hr = m_debugClient->SetEventCallbacks(m_eventCallback);
        }
        hr = m_debugClient->QueryInterface(IID_IDebugSystemObjects, (void**)&m_debugSystemObjects);
        hr = m_debugClient->QueryInterface(IID_IDebugSymbols, (void**)&m_debugSymbols);
    }
  }
  return shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient != NULL));
}$

./content[Boolean DebugEngine::terminate()][Implementation-body] = ${
  if(m_debugSymbols != NULL)
  {
    m_debugSymbols->Release();
    m_debugSymbols = NULL;
  }
  if(m_debugSystemObjects != NULL)
  {
    m_debugSystemObjects->Release();
    m_debugSystemObjects = NULL;
  }
  if(m_debugClient != NULL)
  {
    m_debugClient->EndSession(DEBUG_END_PASSIVE);
    m_debugClient->Release();
    m_debugClient = NULL;
  }
  if(m_debugControl != NULL)
  {
    m_debugControl->Release();
    m_debugControl = NULL;
  }
  delete m_eventCallback;
  m_eventCallback = NULL;
  return shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient == NULL));
}$

./content[Int DebugEngine::DvAlloc(Uint32)][Implementation-body] = ${
  shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativeSize;
	if (check_numeric(size, nativeSize))
	{
        unsigned long long hProcess;
        HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
        if (SUCCEEDED(hr))
        {
            res.reset(new Numeric<EncodingT>((int) VirtualAllocEx((HANDLE) hProcess, NULL, nativeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)));
        }
    }
	return res;
}$

./content[Boolean DebugEngine::DvFree(Int,Uint32)][Implementation-body] = ${
  shared_ptr< Base<EncodingT> > res(new Bool<EncodingT>(false));
	unsigned long nativeSize;
  int nativeBaseAddress;
	if (check_numeric(baseAddress, nativeBaseAddress) && check_numeric(size, nativeSize))
	{
        unsigned long long hProcess;
        HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
        if (SUCCEEDED(hr))
        {
            res.reset(new Bool<EncodingT>(VirtualFreeEx((HANDLE) hProcess, (LPVOID)nativeBaseAddress, nativeSize, MEM_RELEASE)));
        }
  }
	return res;
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugClientPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugClientPtr]

./entity[IDebugClientPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugClient> IDebugClientPtr;
#include "IDebugControlPtrInterpreter.hpp"
}$

./content[Int32 IDebugClientPtr::CreateProcess(AnsiString,Uint32)][Implementation-body] = ${
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	typename EncodingT::string_t nativeCommandLine;
	unsigned long nativeCreateFlags;
	if (check_string<EncodingT>(commandLine, nativeCommandLine) && 
		  check_numeric(createFlags, nativeCreateFlags))
	{
        char ansiCommandLine[MAX_PATH];
        std::copy(nativeCommandLine.begin(), nativeCommandLine.end(), ansiCommandLine);
        res.reset(new Numeric<EncodingT>(value()->CreateProcess(0, ansiCommandLine, nativeCreateFlags)));
	}
	return res;
}$

./content[Int32 IDebugClientPtr::GetRunningProcessSystemIds(Uint32*)][Implementation-body] = ${
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativeId, nativeActualCount;
  res.reset(new Numeric<EncodingT>(value()->GetRunningProcessSystemIds(0, &nativeId, 1, &nativeActualCount)));
	reset_numeric(processId, nativeId);
	return res;
}$

./content[Int32 IDebugClientPtr::GetRunningProcessDescription(Uint32,Uint32,AnsiString,AnsiString)][Implementation-body] = ${
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativeSystemId;
	unsigned long nativeFlags;
	if (check_numeric(systemId, nativeSystemId) && 
		  check_numeric(flags, nativeFlags))
	{
    char ansiNativeExeName[MAX_PATH];
    char ansiNativeDescription[MAX_PATH];
    unsigned long nativeActualExeNameSize, nativeActualDescriptionSize;
		res.reset(new Numeric<EncodingT>(value()->GetRunningProcessDescription(0, nativeSystemId, nativeFlags, ansiNativeExeName, MAX_PATH, &nativeActualExeNameSize, ansiNativeDescription, MAX_PATH, &nativeActualDescriptionSize)));
		reset_string<ansi>(exeName, ansiNativeExeName);
		reset_string<ansi>(description, ansiNativeDescription);
	}
	return res;
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugControlPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugControlPtr]

./entity[IDebugControlPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugControl3> IDebugControlPtr;
#include "IDebugBreakpointPtrInterpreter.hpp"
}$

./content[Int32 IDebugControlPtr::GetPromptText(AnsiString)][Implementation-body] = ${
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	char nativeBuffer[2048];
  res.reset(new Numeric<EncodingT>(value()->GetPromptText(nativeBuffer, 2048, NULL)));
	reset_string<ansi>(buffer, nativeBuffer);
	return res;
}$

///////////////////////////////////////////////////////////////////////////////
// DebugStatus
///////////////////////////////////////////////////////////////////////////////

file[DebugStatus]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// CreateFlags
///////////////////////////////////////////////////////////////////////////////

file[CreateFlags]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// WaitFlags
///////////////////////////////////////////////////////////////////////////////

file[WaitFlags]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// TimeOut
///////////////////////////////////////////////////////////////////////////////

file[TimeOut]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DEBUG_VALUE
///////////////////////////////////////////////////////////////////////////////

file[DEBUG_VALUE]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugValue
///////////////////////////////////////////////////////////////////////////////

file[DebugValue]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugExecute
///////////////////////////////////////////////////////////////////////////////

file[DebugExecute]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugOutCTL
///////////////////////////////////////////////////////////////////////////////

file[DebugOutCTL]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugSystemObjectsPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugSystemObjectsPtr]

./entity[IDebugSystemObjectsPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugSystemObjects> IDebugSystemObjectsPtr;
}$

./content[Int32 IDebugSystemObjectsPtr::GetCurrentProcessExecutableName(AnsiString)][Implementation-body] = ${
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	char nativeBuffer[MAX_PATH];
  res.reset(new Numeric<EncodingT>(value()->GetCurrentProcessExecutableName(nativeBuffer, MAX_PATH, NULL)));
	reset_string<ansi>(buffer, nativeBuffer);
	return res;
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugSymbolsPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugSymbolsPtr]

./entity[IDebugSymbolsPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugSymbols> IDebugSymbolsPtr;
}$

///////////////////////////////////////////////////////////////////////////////
// ImageFileMachine
///////////////////////////////////////////////////////////////////////////////

file[ImageFileMachine]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugBreakpoint
///////////////////////////////////////////////////////////////////////////////

file[DebugBreakpoint]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// DebugBreakpointFlag
///////////////////////////////////////////////////////////////////////////////

file[DebugBreakpointFlag]
./content[Global-inclusion] = ${
}$

///////////////////////////////////////////////////////////////////////////////
// IDebugBreakpointPtr
///////////////////////////////////////////////////////////////////////////////

file[IDebugBreakpointPtr]

./entity[IDebugBreakpointPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DebugPtr.h"
typedef CDebugPtr<IDebugBreakpoint> IDebugBreakpointPtr;
}$

