/*
 * IDiaSymbolPtrInterpreter_impl.hpp
 *
 *
 * @date 21-06-2016
 * @author Teddy DIDE
 * @version 1.00
 * Pdb Interpreter generated by gensources.
 */

#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(interp)

template <class EncodingT>
class IDiaEnumSymbolsPtrInterpreter;

template <class EncodingT>
class SymTagEnumTypeInterpreter;

template <class EncodingT>
IDiaSymbolPtrInterpreter<EncodingT>::IDiaSymbolPtrInterpreter()
{
}

template <class EncodingT>
void IDiaSymbolPtrInterpreter<EncodingT>::tidyValue()
{
}

template <class EncodingT>
IDiaSymbolPtrInterpreter<EncodingT>::~IDiaSymbolPtrInterpreter()
{
	tidyValue();
}

template <class EncodingT>
void IDiaSymbolPtrInterpreter<EncodingT>::initValue(const IDiaSymbolPtr& object)
{
	m_object = object;
}

template <class EncodingT>
IDiaSymbolPtr& IDiaSymbolPtrInterpreter<EncodingT>::value()
{
	return m_object;
}

template <class EncodingT>
const IDiaSymbolPtr& IDiaSymbolPtrInterpreter<EncodingT>::value() const
{
	return m_object;
}

template <class EncodingT>
IDiaSymbolPtrInterpreter<EncodingT>::IDiaSymbolPtrInterpreter(const IDiaSymbolPtr& object)
{
	initValue(object);
}

template <class EncodingT>
IDiaSymbolPtrInterpreter<EncodingT>::IDiaSymbolPtrInterpreter(const IDiaSymbolPtrInterpreter<EncodingT>& rhs)
{
	initValue(rhs.value());
}

template <class EncodingT>
IDiaSymbolPtrInterpreter<EncodingT>& IDiaSymbolPtrInterpreter<EncodingT>::operator=(const IDiaSymbolPtrInterpreter<EncodingT>& rhs)
{
	setValue(rhs.value());
	return *this;
}

template <class EncodingT>
const IDiaSymbolPtr& IDiaSymbolPtrInterpreter<EncodingT>::getValue() const
{
	return value();
}

template <class EncodingT>
void IDiaSymbolPtrInterpreter<EncodingT>::setValue(IDiaSymbolPtr const& object)
{
	tidyValue();
	initValue(object);
}

template <class EncodingT>
typename EncodingT::string_t IDiaSymbolPtrInterpreter<EncodingT>::toString() const
{
	return EncodingT::EMPTY;
}

template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::clone() const
{
	return shared_ptr< Base<EncodingT> >(new IDiaSymbolPtrInterpreter<EncodingT>(*this));
}

template <class EncodingT>
typename EncodingT::string_t IDiaSymbolPtrInterpreter<EncodingT>::getClassName() const
{
	return C("IDiaSymbolPtr");
}

template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::invoke(const typename EncodingT::string_t& method, std::vector< shared_ptr< Base<EncodingT> > >& params)
{
	shared_ptr< Base<EncodingT> > obj(new Base<EncodingT>());
	ParameterArray args, ret;
	if (check_parameters_array(params, args))
	{
		if (tryInvoke(this, C("IDiaSymbolPtr"), method, args, ret))
		{
			find_parameter(ret, FACTORY_RETURN_PARAMETER, obj);
			for (size_t i = 0; i < params.size(); ++i)
			{
				find_parameter(ret, i, params[i]);
			}
		}
		else
		{
			Category* logger = &Category::getInstance(LOGNAME);
			logger->errorStream() << "Unexpected call in IDiaSymbolPtr, no method \"" << A(method) << "\" exists.";
		}
	}
	return obj;
}

// Récupère les enfants du symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::findChildren(const shared_ptr< Base<EncodingT> >& symtag, const shared_ptr< Base<EncodingT> >& name, const shared_ptr< Base<EncodingT> >& compareFlags, shared_ptr< Base<EncodingT> >& ppResult)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	SymTagEnumType nativeSymtag;
	typename EncodingT::string_t nativeName;
	long nativeCompareFlags;
	IDiaEnumSymbolsPtr nativePpResult;
	if (check_SymTagEnumType(symtag, nativeSymtag) && 
		check_string<EncodingT>(name, nativeName) && 
		check_numeric(compareFlags, nativeCompareFlags) && 
		check_IDiaEnumSymbolsPtr(ppResult, nativePpResult))
	{
		res.reset(new Numeric<EncodingT>(value()->findChildren(nativeSymtag, nativeName.c_str(), nativeCompareFlags, &nativePpResult)));
		reset_IDiaEnumSymbolsPtr(ppResult, nativePpResult);
	}
	return res;
}

// Récupère les enfants du symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::findChildren(const shared_ptr< Base<EncodingT> >& symtag, shared_ptr< Base<EncodingT> >& ppResult)
{
shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	SymTagEnumType nativeSymtag;
	IDiaEnumSymbolsPtr nativePpResult;
	if (check_SymTagEnumType(symtag, nativeSymtag) && 
		  check_IDiaEnumSymbolsPtr(ppResult, nativePpResult))
	{
		res.reset(new Numeric<EncodingT>(value()->findChildren(nativeSymtag, NULL, nsNone, &nativePpResult)));
		reset_IDiaEnumSymbolsPtr(ppResult, nativePpResult);
	}
	return res;
}

// Extrait le nom du symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_name(shared_ptr< Base<EncodingT> >& pRetVal)
{
shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
    BSTR nativePRetVal;
    res.reset(new Numeric<EncodingT>(value()->get_name(&nativePRetVal)));
    reset_string<EncodingT>(pRetVal, nativePRetVal);
	  return res;
}

// Extrait la partie de section d'un emplacement d'adresse.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_addressSection(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_addressSection(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Extrait la partie d'offset à un emplacement d'adresse.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_addressOffset(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_addressOffset(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère l'adresse virtuelle relative (RVA) du symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_relativeVirtualAddress(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_relativeVirtualAddress(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère le symbole qui représente le type pour ce symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_type(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	IDiaSymbolPtr nativePRetVal;
	if (check_IDiaSymbolPtr(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_type(&nativePRetVal)));
		reset_IDiaSymbolPtr(pRetVal, nativePRetVal);
	}
	return res;
}

// Extrait une balise qui indique si le type de données défini par l'utilisateur est constante.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_constType(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	int nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_constType(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// extrait la classification variable d'un symbole de données.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_dataKind(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_dataKind(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Extrait une balise qui indique si le type de données défini par l'utilisateur possède un constructeur ou un destructeur.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_constructor(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	int nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_constructor(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère le type de base pour ce symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_baseType(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_baseType(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Extrait une balise qui indique si le type de données défini par (UDT) l'utilisateur est volatile.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_volatileType(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	int nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_volatileType(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// extrait une balise qui spécifie si la fonction est virtuelle.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_virtual(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	int nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_virtual(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Extrait une balise qui spécifie si la fonction ou la couche de conversion de code a été marquée comme static.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_isStatic(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	int nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_isStatic(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Spécifie si la variable distribue une valeur de retour.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_isReturnValue(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	int nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_isReturnValue(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère le classifieur de type de symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_symTag(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_symTag(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère le nombre de bits ou d'octets de mémoire utilisés par l'objet représenté par ce symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_length(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_length(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// extrait une balise qui spécifie si un type pointeur est une référence.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_reference(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	int nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_reference(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère le rang (nombre de dimensions) d'un tableau multidimensionnel FORTRAN.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_rank(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_rank(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Extrait la limite inférieure d'une dimension de tableau FORTRAN.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_lowerBound(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	IDiaSymbolPtr nativePRetVal;
	if (check_IDiaSymbolPtr(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_lowerBound(&nativePRetVal)));
		reset_IDiaSymbolPtr(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère un symbole représentant la limite supérieure d'une dimension de tableau FORTRAN.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_upperBound(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	IDiaSymbolPtr nativePRetVal;
	if (check_IDiaSymbolPtr(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_upperBound(&nativePRetVal)));
		reset_IDiaSymbolPtr(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère la valeur du fabricant d'ordinateurs (OEM) OEM du symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_oemId(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_oemId(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère la valeur (OEM) du symbole de fabricant d'ordinateurs OEM.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_oemSymbolId(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_oemSymbolId(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}

// Récupère un tableau de types de compilateur-détail pour ce symbole.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_types(shared_ptr< Base<EncodingT> >& types)
{
shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	std::vector< IDiaSymbolPtr > nativeTypes;
  DWORD count;
  HRESULT hres = value()->get_types(0, &count, NULL);
  if (hres == S_OK) 
  {
    IDiaSymbol** rgpDiaSymbols = (IDiaSymbol**) _alloca(sizeof(IDiaSymbol *) * count);
    hres = value()->get_types(count, &count, rgpDiaSymbols);
    if (hres == S_OK) 
    {
      for (ULONG i = 0; i < count; i++) 
      {
        nativeTypes.push_back(IDiaSymbolPtr(rgpDiaSymbols[i]));
        rgpDiaSymbols[i]->Release();
      }
    }
  }
  res.reset(new Numeric<EncodingT>(hres));
  reset_array(types, nativeTypes, reset_IDiaSymbolPtr<EncodingT>);
	return res;
}

// Récupère les octets de données d'un symbole OEM.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_dataBytes(const shared_ptr< Base<EncodingT> >& cbData, shared_ptr< Base<EncodingT> >& pcbData, shared_ptr< Base<EncodingT> >& data)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativeCbData;
	unsigned long nativePcbData;
	std::vector< unsigned char > nativeData;
	if (check_numeric(cbData, nativeCbData) && 
		check_numeric(pcbData, nativePcbData) && 
		check_array(data, nativeData, check_numeric<EncodingT, unsigned char>))
	{
		res.reset(new Numeric<EncodingT>(value()->get_dataBytes(nativeCbData, &nativePcbData, nativeData.data())));
		reset_numeric(pcbData, nativePcbData);
		reset_array(data, nativeData, reset_numeric<EncodingT, unsigned char>);
	}
	return res;
}

// Extrait le dossier fichiers divers un type défini par l' (UDT)utilisateur.
template <class EncodingT>
shared_ptr< Base<EncodingT> > IDiaSymbolPtrInterpreter<EncodingT>::get_udtKind(shared_ptr< Base<EncodingT> >& pRetVal)
{
	shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativePRetVal;
	if (check_numeric(pRetVal, nativePRetVal))
	{
		res.reset(new Numeric<EncodingT>(value()->get_udtKind(&nativePRetVal)));
		reset_numeric(pRetVal, nativePRetVal);
	}
	return res;
}


template <class EncodingT>
bool check_IDiaSymbolPtr(shared_ptr< Base<EncodingT> > const& val, IDiaSymbolPtr& a)
{
	shared_ptr< IDiaSymbolPtrInterpreter<EncodingT> > value  = dynamic_pointer_cast< IDiaSymbolPtrInterpreter<EncodingT> >(val);
	if (value)
	{
		a = value->getValue();
	}
	else
	{
		Category * logger = &Category::getInstance(LOGNAME);
		logger->errorStream() << "IDiaSymbolPtr expected, got " << A(val->getClassName());
	}
	return value;
}

template <class EncodingT>
bool reset_IDiaSymbolPtr(shared_ptr< Base<EncodingT> >& val, IDiaSymbolPtr const& a)
{
	shared_ptr< IDiaSymbolPtrInterpreter<EncodingT> > value  = dynamic_pointer_cast< IDiaSymbolPtrInterpreter<EncodingT> >(val);
	if (value)
	{
		value->setValue(a);
	}
	else
	{
		Category* logger = &Category::getInstance(LOGNAME);
		logger->errorStream() << "IDiaSymbolPtr expected, got " << A(val->getClassName());
	}
	return value;
}

NAMESPACE_END

#undef A
#undef C