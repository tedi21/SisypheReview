///////////////////////////////////////////////////////////////////////////////
// Workspace
///////////////////////////////////////////////////////////////////////////////

Author = Teddy DIDE; 
Brief = Pdb Interpreter generated by gensources.;
Name = Pdb_interpreter;
Option = 0;
Type = Project;
Version = 1.00;

///////////////////////////////////////////////////////////////////////////////
// PdbParser
///////////////////////////////////////////////////////////////////////////////

file[PdbParser]

./content[Global-inclusion] = ${
#include "Bool.hpp"
// Debug Interface Access (DIA) specific
#include <dia2.h>
#include "IDiaDataSourcePtrInterpreter.hpp"
}$

./content[Global-body] = ${
template <class EncodingT>
IDiaDataSource* interp::PdbParserInterpreter<EncodingT>::m_diaDataSource = NULL;
}$

./content[Declaration] = ${
private:
  static IDiaDataSource *m_diaDataSource;
  
public:
  // Retourne l'objet DiaDataSource
  boost::shared_ptr< Base<EncodingT> > getDataSource() const;
}$

./content[Implementation] = ${
// Retourne l'objet DiaDataSource
template <class EncodingT>
boost::shared_ptr< Base<EncodingT> > PdbParserInterpreter<EncodingT>::getDataSource() const
{
  return boost::shared_ptr< Base<EncodingT> > (new IDiaDataSourcePtrInterpreter<EncodingT>(m_diaDataSource));
}
}$

./content[Register] = ${
METHOD_KEY_REGISTER ( PdbParserInterpreter, boost::shared_ptr< Base<EncodingT> >, getDataSource, const_t, C("PdbParser::DataSource") );
}$

./content[Unregister] = ${
METHOD_KEY_UNREGISTER ( C("PdbParser::DataSource") );
}$

./content[Boolean PdbParser::initialize()][Implementation-body] = ${
static GUID IID_IDiaDataSource = {0x79F1BB5F,0xB66E,0x48e5,{0xB6,0xA9,0x15,0x45,0xC3,0x23,0xCA,0x3D}};
static GUID IID_DiaSource = {0xE6756135,0x1E65,0x4D17,{0x85,0x76,0x61,0x07,0x61,0x39,0x8C,0x3C}};
if (m_diaDataSource == NULL)
{
  IDiaDataSource  *ppSource;
  HRESULT hr = CoInitialize(NULL);
  hr = CoCreateInstance(IID_DiaSource,
                  NULL,
                  CLSCTX_INPROC_SERVER,
                  IID_IDiaDataSource,
                  (void **) &ppSource);
  if(SUCCEEDED(hr)) m_diaDataSource = ppSource;
}
return boost::shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_diaDataSource != NULL));
}$

./content[Boolean PdbParser::terminate()][Implementation-body] = ${
if(m_diaDataSource != NULL)
{
  m_diaDataSource->Release();
  m_diaDataSource = NULL;
  CoUninitialize();
}
return boost::shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_diaDataSource == NULL));
}$

// Documentation

./content[Boolean PdbParser::initialize()]
./-[ReturnDescription] = ${
True si l'initialisation est effectuée.
}$
  
./-[Example] = ${
pdbParser = new PdbParser();
pdbParser.Initialize();
pdbDataSource = pdbParser.DataSource;
}$
   
./content[Boolean PdbParser::terminate()]
./-[ReturnDescription] = ${
True si la destruction est effectuée.
}$
   
./-[Example] = ${
pdbParser.Terminate();
pdbParser = null;
}$

///////////////////////////////////////////////////////////////////////////////
// IDiaDataSourcePtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaDataSourcePtr]

./entity[IDiaDataSourcePtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaDataSource> IDiaDataSourcePtr;
#include "IDiaSessionPtrInterpreter.hpp"
}$

// Documentation

./content[Int32 IDiaDataSourcePtr::loadDataFromPdb(String)]
./-[ReturnDescription] = ${
0 si la lecture du fichier PDB est effectuée.
}$

./-[ParameterDescription][pdbPath] = ${
Le chemin du fichier PDB à ouvrir.
}$

./-[Example] = ${
pdbParser = new PdbParser();
pdbParser.Initialize();
pdbDataSource = pdbParser.DataSource;
pdbDataSource.LoadDataFromPdb("projet.pdb");
}$

///////////////////////////////////////////////////////////////////////////////
// IDiaSessionPtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaSessionPtr]

./entity[IDiaSessionPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaSession> IDiaSessionPtr;
#include "IDiaSymbolPtrInterpreter.hpp"
#include "IDiaEnumLineNumbersPtrInterpreter.hpp"
#include "IDiaEnumSourceFilesPtrInterpreter.hpp"
}$


./content[Int32 IDiaSessionPtr::findFile(String,Uint32,IDiaEnumSourceFilesPtr*)][Implementation-body] = ${
	boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	typename EncodingT::string_t nativeName;
	unsigned long nativeOption;
	IDiaEnumSourceFilesPtr nativePpResult;
	if (check_string<EncodingT>(name, nativeName) && 
		check_numeric(option, nativeOption) && 
		check_IDiaEnumSourceFilesPtr(ppResult, nativePpResult))
	{
		res.reset(new Numeric<EncodingT>(value()->findFile(NULL, nativeName.c_str(), nativeOption, &nativePpResult)));
		reset_IDiaEnumSourceFilesPtr(ppResult, nativePpResult);
	}
	return res;
}$

./content[Int32 IDiaSessionPtr::findFile(IDiaEnumSourceFilesPtr*)][Implementation-body] = ${
	boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	IDiaEnumSourceFilesPtr nativePpResult;
	if (check_IDiaEnumSourceFilesPtr(ppResult, nativePpResult))
	{
		res.reset(new Numeric<EncodingT>(value()->findFile(NULL, NULL, nsNone, &nativePpResult)));
		reset_IDiaEnumSourceFilesPtr(ppResult, nativePpResult);
	}
	return res;
}$

./content[Int32 IDiaSessionPtr::findFile(IDiaSymbolPtr,IDiaEnumSourceFilesPtr*)][Implementation-body] = ${
	boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
  IDiaSymbolPtr nativePCompiland;
	IDiaEnumSourceFilesPtr nativePpResult;
	if (check_IDiaSymbolPtr(pCompiland, nativePCompiland) &&
      check_IDiaEnumSourceFilesPtr(ppResult, nativePpResult))
	{
		res.reset(new Numeric<EncodingT>(value()->findFile(nativePCompiland, NULL, nsNone, &nativePpResult)));
		reset_IDiaEnumSourceFilesPtr(ppResult, nativePpResult);
	}
	return res;
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// IDiaSymbolPtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaSymbolPtr]

./entity[IDiaSymbolPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaSymbol> IDiaSymbolPtr;
#include "IDiaEnumSymbolsPtrInterpreter.hpp"
#include "SymTagEnumTypeInterpreter.hpp"
}$

./content[Int32 IDiaSymbolPtr::get_name(String*)][Implementation-body] = ${
	  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
    BSTR nativePRetVal;
    res.reset(new Numeric<EncodingT>(value()->get_name(&nativePRetVal)));
    reset_string<EncodingT>(pRetVal, nativePRetVal);
	  return res;
}$

./content[Int32 IDiaSymbolPtr::findChildren(SymTagEnumType,IDiaEnumSymbolsPtr*)][Implementation-body] = ${
	boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	SymTagEnumType nativeSymtag;
	IDiaEnumSymbolsPtr nativePpResult;
	if (check_SymTagEnumType(symtag, nativeSymtag) && 
		  check_IDiaEnumSymbolsPtr(ppResult, nativePpResult))
	{
		res.reset(new Numeric<EncodingT>(value()->findChildren(nativeSymtag, NULL, nsNone, &nativePpResult)));
		reset_IDiaEnumSymbolsPtr(ppResult, nativePpResult);
	}
	return res;
}$

./content[Int32 IDiaSymbolPtr::get_types(IDiaSymbolPtr)][Implementation-body] = ${
	boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	std::vector< IDiaSymbolPtr > nativeTypes;
  DWORD count;
  HRESULT hres = value()->get_types(0, &count, NULL);
  if (hres == S_OK) 
  {
    IDiaSymbol** rgpDiaSymbols = (IDiaSymbol**) _alloca(sizeof(IDiaSymbol *) * count);
    hres = value()->get_types(count, &count, rgpDiaSymbols);
    if (hres == S_OK) 
    {
      for (ULONG i = 0; i < count; i++) 
      {
        nativeTypes.push_back(IDiaSymbolPtr(rgpDiaSymbols[i]));
        rgpDiaSymbols[i]->Release();
      }
    }
  }
  res.reset(new Numeric<EncodingT>(hres));
  reset_array(types, nativeTypes, reset_IDiaSymbolPtr<EncodingT>);
	return res;
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// IDiaEnumSymbolsPtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaEnumSymbolsPtr]

./entity[IDiaEnumSymbolsPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaEnumSymbols> IDiaEnumSymbolsPtr;
#include "IDiaSymbolPtrInterpreter.hpp"
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// SymTagEnumType
///////////////////////////////////////////////////////////////////////////////

file[SymTagEnumType]

./content[Global-inclusion] = ${
typedef enum SymTagEnum SymTagEnumType;

NAMESPACE_BEGIN(interp)

template <class EncodingT>
bool check_SymTagEnumType(boost::shared_ptr< Base<EncodingT> > const& val, SymTagEnumType& s);

NAMESPACE_END
}$

./content[Global-body] = ${
NAMESPACE_BEGIN(interp)

template <class EncodingT>
bool check_SymTagEnumType(boost::shared_ptr< Base<EncodingT> > const& val, SymTagEnumType& s)
{
	boost::shared_ptr< Numeric<EncodingT> > value  = dynamic_pointer_cast< Numeric<EncodingT> >(val);
	if (value)
	{
		s = (SymTagEnumType) value->getValue();
	}
	else
	{
		Category * logger = &Category::getInstance(LOGNAME);
		logger->errorStream() << "Numeric expected, got " << A(val->getClassName());
	}
	return (value != NULL);
}

NAMESPACE_END
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// NameSearchOptions
///////////////////////////////////////////////////////////////////////////////

file[NameSearchOptions]

./content[Global-inclusion] = ${
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// IDiaLineNumberPtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaLineNumberPtr]

./entity[IDiaLineNumberPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaLineNumber> IDiaLineNumberPtr;
#include "IDiaSourceFilePtrInterpreter.hpp"
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// IDiaEnumLineNumbersPtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaEnumLineNumbersPtr]

./entity[IDiaEnumLineNumbersPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaEnumLineNumbers> IDiaEnumLineNumbersPtr;
#include "IDiaLineNumberPtrInterpreter.hpp"
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// IDiaSourceFilePtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaSourceFilePtr]

./entity[IDiaSourceFilePtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaSourceFile> IDiaSourceFilePtr;
}$

./content[Int32 IDiaSourceFilePtr::get_fileName(String*)][Implementation-body] = ${
	  boost::shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
    BSTR nativePRetVal;
    res.reset(new Numeric<EncodingT>(value()->get_fileName(&nativePRetVal)));
    reset_string<EncodingT>(pRetVal, nativePRetVal);
    return res;
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// IDiaEnumSourceFilesPtr
///////////////////////////////////////////////////////////////////////////////

file[IDiaEnumSourceFilesPtr]

./entity[IDiaEnumSourceFilesPtr]/Attribute[Id]/Modifier = Virtual;

./content[Global-inclusion] = ${
#include "DiaPtr.h"
typedef CDiaPtr<IDiaEnumSourceFiles> IDiaEnumSourceFilesPtr;
#include "IDiaSourceFilePtrInterpreter.hpp"
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// DataKind
///////////////////////////////////////////////////////////////////////////////

file[DataKind]

./content[Global-inclusion] = ${
}$

// Documentation

///////////////////////////////////////////////////////////////////////////////
// BasicType
///////////////////////////////////////////////////////////////////////////////

file[BasicType]

./content[Global-inclusion] = ${
}$

// Documentation
