/*
 * WordXMLNodeInterpreter_impl.hpp
 *
 *
 * @date 21-06-2016
 * @author Teddy DIDE
 * @version 1.00
 * Word Interpreter generated by gensources.
 */

#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(interp)

template <class EncodingT>
class StringListInterpreter;

template <class EncodingT>
class WordXMLDocumentInterpreter;

template <class EncodingT>
class WordXMLNodeListInterpreter;

template <class EncodingT>
WordXMLNodeInterpreter<EncodingT>::WordXMLNodeInterpreter()
{
}

template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::tidyValue()
{
}

template <class EncodingT>
WordXMLNodeInterpreter<EncodingT>::~WordXMLNodeInterpreter()
{
	tidyValue();
}

template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::initValue(const WordXMLNode& object)
{
	m_object = object;
}

template <class EncodingT>
WordXMLNode& WordXMLNodeInterpreter<EncodingT>::value()
{
	return m_object;
}

template <class EncodingT>
const WordXMLNode& WordXMLNodeInterpreter<EncodingT>::value() const
{
	return m_object;
}

template <class EncodingT>
WordXMLNodeInterpreter<EncodingT>::WordXMLNodeInterpreter(const WordXMLNode& object)
{
	initValue(object);
}

template <class EncodingT>
WordXMLNodeInterpreter<EncodingT>::WordXMLNodeInterpreter(const WordXMLNodeInterpreter<EncodingT>& rhs)
{
	initValue(rhs.value());
}

template <class EncodingT>
WordXMLNodeInterpreter<EncodingT>& WordXMLNodeInterpreter<EncodingT>::operator=(const WordXMLNodeInterpreter<EncodingT>& rhs)
{
	setValue(rhs.value());
	return *this;
}

template <class EncodingT>
const WordXMLNode& WordXMLNodeInterpreter<EncodingT>::getValue() const
{
	return value();
}

template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::setValue(WordXMLNode const& object)
{
	tidyValue();
	initValue(object);
}

template <class EncodingT>
typename EncodingT::string_t WordXMLNodeInterpreter<EncodingT>::toString() const
{
	return EncodingT::EMPTY;
}

template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::clone() const
{
	return shared_ptr< Base<EncodingT> >(new WordXMLNodeInterpreter<EncodingT>(*this));
}

template <class EncodingT>
typename EncodingT::string_t WordXMLNodeInterpreter<EncodingT>::getClassName() const
{
	return C("WordXMLNode");
}

template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::invoke(const typename EncodingT::string_t& method, std::vector< shared_ptr< Base<EncodingT> > >& params)
{
	shared_ptr< Base<EncodingT> > obj(new Base<EncodingT>());
	ParameterArray args, ret;
	if (check_parameters_array(params, args))
	{
		if (tryInvoke(this, C("WordXMLNode"), method, args, ret))
		{
			find_parameter(ret, FACTORY_RETURN_PARAMETER, obj);
			for (size_t i = 0; i < params.size(); ++i)
			{
				find_parameter(ret, i, params[i]);
			}
		}
		else
		{
			Category* logger = &Category::getInstance(LOGNAME);
			logger->errorStream() << "Unexpected call in WordXMLNode, no method \"" << A(method) << "\" exists.";
		}
	}
	return obj;
}

// Le nom du noeud *DOCUMENT*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getDOCUMENT_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::DOCUMENT_TAG));
}

// Le nom du noeud *BODY*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getBODY_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::BODY_TAG));
}

// Le nom du noeud *SECTION*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getSECTION_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::SECTION_TAG));
}

// Le nom du noeud *SUBSECTION*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getSUBSECTION_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::SUBSECTION_TAG));
}

// Le nom du noeud *TABLE*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getTABLE_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::TABLE_TAG));
}

// Le nom du noeud *ROW*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getROW_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::ROW_TAG));
}

// Le nom du noeud *CELL*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getCELL_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::CELL_TAG));
}

// Le nom du noeud *PARAGRAPH*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getPARAGRAPH_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::PARAGRAPH_TAG));
}

// Le nom du noeud *REVISION*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getREVISION_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::REVISION_TAG));
}

// Le nom du noeud *RUN*. 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getRUN_TAG() const
{
	return shared_ptr< Base<EncodingT> > (new String<EncodingT>(WordXMLNode::RUN_TAG));
}

// Valeur par défaut indiquant que le paramètre de la taille est à ignorer (cf. méthode *eraseString*). 
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getNO_LENGTH() const
{
	return shared_ptr< Base<EncodingT> > (new Numeric<EncodingT>(WordXMLNode::NO_LENGTH));
}

// Retourne le nom du noeud.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getTagName() const
{
	shared_ptr< Base<EncodingT> > res(new String<EncodingT>());
	res.reset(new String<EncodingT>(value().getTagName()));
	return res;
}

// Execute une requête XPath.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::evaluate(const shared_ptr< Base<EncodingT> >& xpath) const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeListInterpreter<EncodingT>());
	typename EncodingT::string_t nativeXpath;
	if (check_string<EncodingT>(xpath, nativeXpath))
	{
		res.reset(new WordXMLNodeListInterpreter<EncodingT>(value().evaluate(nativeXpath.c_str())));
	}
	return res;
}

// Retourne les noeuds fils.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getNodes() const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeListInterpreter<EncodingT>());
	res.reset(new WordXMLNodeListInterpreter<EncodingT>(value().getNodes()));
	return res;
}

// Retourne les noeuds fils avec le nom *tagName*.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getNodes(const shared_ptr< Base<EncodingT> >& tagName) const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeListInterpreter<EncodingT>());
	typename EncodingT::string_t nativeTagName;
	if (check_string<EncodingT>(tagName, nativeTagName))
	{
		res.reset(new WordXMLNodeListInterpreter<EncodingT>(value().getNodes(nativeTagName.c_str())));
	}
	return res;
}

// Retourne le noeud suivant.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getNextNode() const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	res.reset(new WordXMLNodeInterpreter<EncodingT>(value().getNextNode()));
	return res;
}

// Retourne le noeud suivant avec le nom *tagName*.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getNextNode(const shared_ptr< Base<EncodingT> >& tagName) const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	typename EncodingT::string_t nativeTagName;
	if (check_string<EncodingT>(tagName, nativeTagName))
	{
		res.reset(new WordXMLNodeInterpreter<EncodingT>(value().getNextNode(nativeTagName.c_str())));
	}
	return res;
}

// Retourne le noeud précèdent.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getPreviousNode() const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	res.reset(new WordXMLNodeInterpreter<EncodingT>(value().getPreviousNode()));
	return res;
}

// Retourne le noeud précèdent avec le nom *tagName*.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getPreviousNode(const shared_ptr< Base<EncodingT> >& tagName) const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	typename EncodingT::string_t nativeTagName;
	if (check_string<EncodingT>(tagName, nativeTagName))
	{
		res.reset(new WordXMLNodeInterpreter<EncodingT>(value().getPreviousNode(nativeTagName.c_str())));
	}
	return res;
}

// Retourne le noeud parent.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getParent() const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	res.reset(new WordXMLNodeInterpreter<EncodingT>(value().getParent()));
	return res;
}

// Retourne le noeud parent avec le nom *tagName*.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getParent(const shared_ptr< Base<EncodingT> >& tagName) const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	typename EncodingT::string_t nativeTagName;
	if (check_string<EncodingT>(tagName, nativeTagName))
	{
		res.reset(new WordXMLNodeInterpreter<EncodingT>(value().getParent(nativeTagName.c_str())));
	}
	return res;
}

// Retourne le contenu d'un noeud.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getContent() const
{
	shared_ptr< Base<EncodingT> > res(new String<EncodingT>());
	res.reset(new String<EncodingT>(value().getContent()));
	return res;
}

// Indique si le noeud à un attribut *attrName*.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::hasAttribute(const shared_ptr< Base<EncodingT> >& attrName) const
{
	shared_ptr< Base<EncodingT> > res(new Bool<EncodingT>());
	typename EncodingT::string_t nativeAttrName;
	if (check_string<EncodingT>(attrName, nativeAttrName))
	{
		res.reset(new Bool<EncodingT>(value().hasAttribute(nativeAttrName.c_str())));
	}
	return res;
}

// Retourne la valeur de l'attribut *attrName*.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getAttribute(const shared_ptr< Base<EncodingT> >& attrName) const
{
	shared_ptr< Base<EncodingT> > res(new String<EncodingT>());
	typename EncodingT::string_t nativeAttrName;
	if (check_string<EncodingT>(attrName, nativeAttrName))
	{
		res.reset(new String<EncodingT>(value().getAttribute(nativeAttrName.c_str())));
	}
	return res;
}

// Retourne les noms des attributs du noeud.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getAttributesNames() const
{
	shared_ptr< Base<EncodingT> > res(new StringListInterpreter<EncodingT>());
	res.reset(new StringListInterpreter<EncodingT>(value().getAttributesNames()));
	return res;
}

// Retourne le texte brut du noeud.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getString() const
{
	shared_ptr< Base<EncodingT> > res(new String<EncodingT>());
	res.reset(new String<EncodingT>(value().getString()));
	return res;
}

// Retourne le document.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::getDocument() const
{
shared_ptr< Base<EncodingT> > res(new WordXMLDocumentInterpreter<EncodingT>());
    res.reset(new WordXMLDocumentInterpreter<EncodingT>(*m_object.getDocument()));
    return res;
}

// Indique si le noeud est valide.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::isValid() const
{
	shared_ptr< Base<EncodingT> > res(new Bool<EncodingT>());
	res.reset(new Bool<EncodingT>(value().isValid()));
	return res;
}

// Définit le contenu.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::setContent(const shared_ptr< Base<EncodingT> >& content)
{
	typename EncodingT::string_t nativeContent;
	if (check_string<EncodingT>(content, nativeContent))
	{
		value().setContent(nativeContent.c_str());
	}
}

// Définit un attribut.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::setAttribute(const shared_ptr< Base<EncodingT> >& attrName, const shared_ptr< Base<EncodingT> >& attrValue)
{
	typename EncodingT::string_t nativeAttrName;
	typename EncodingT::string_t nativeAttrValue;
	if (check_string<EncodingT>(attrName, nativeAttrName) && 
		check_string<EncodingT>(attrValue, nativeAttrValue))
	{
		value().setAttribute(nativeAttrName.c_str(), nativeAttrValue.c_str());
	}
}

// Supprime un attribut.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::eraseAttribute(const shared_ptr< Base<EncodingT> >& attrName)
{
	typename EncodingT::string_t nativeAttrName;
	if (check_string<EncodingT>(attrName, nativeAttrName))
	{
		value().eraseAttribute(nativeAttrName.c_str());
	}
}

// Retourne le noeud Propriétés correspondant au noeud conteneur en cours ou crée le noeud si celui-ci n'existe pas.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::createPropertiesNode()
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	res.reset(new WordXMLNodeInterpreter<EncodingT>(value().createPropertiesNode()));
	return res;
}

// Définit le noeud *Propriétés*.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::setPropertiesNode(const shared_ptr< Base<EncodingT> >& node)
{
	WordXMLNode nativeNode;
	if (check_WordXMLNode(node, nativeNode))
	{
		value().setPropertiesNode(nativeNode);
	}
}

// Supprime le noeud *Propriétés*.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::erasePropertiesNode()
{
	value().erasePropertiesNode();
}

// Ajoute un nouveau noeud.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::append(const shared_ptr< Base<EncodingT> >& newChild)
{
	WordXMLNode nativeNewChild;
	if (check_WordXMLNode(newChild, nativeNewChild))
	{
		value().append(nativeNewChild);
	}
}

// Supprime le noeud.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::erase()
{
	value().erase();
}

// Remplace un noeud.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::replace(const shared_ptr< Base<EncodingT> >& newChild, const shared_ptr< Base<EncodingT> >& oldChild)
{
	WordXMLNode nativeNewChild;
	WordXMLNode nativeOldChild;
	if (check_WordXMLNode(newChild, nativeNewChild) && 
		check_WordXMLNode(oldChild, nativeOldChild))
	{
		value().replace(nativeNewChild, nativeOldChild);
	}
}

// Insère un nouveau noeud.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::insertBefore(const shared_ptr< Base<EncodingT> >& newChild, const shared_ptr< Base<EncodingT> >& refChild)
{
	WordXMLNode nativeNewChild;
	WordXMLNode nativeRefChild;
	if (check_WordXMLNode(newChild, nativeNewChild) && 
		check_WordXMLNode(refChild, nativeRefChild))
	{
		value().insertBefore(nativeNewChild, nativeRefChild);
	}
}

// Clone le noeud.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::cloneNode(const shared_ptr< Base<EncodingT> >& deep) const
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeInterpreter<EncodingT>());
	bool nativeDeep;
	if (check_bool(deep, nativeDeep))
	{
		res.reset(new WordXMLNodeInterpreter<EncodingT>(value().cloneNode(nativeDeep)));
	}
	return res;
}

// Ajoute du texte.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::appendString(const shared_ptr< Base<EncodingT> >& trackedChanges, const shared_ptr< Base<EncodingT> >& str)
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeListInterpreter<EncodingT>());
	bool nativeTrackedChanges;
	typename EncodingT::string_t nativeStr;
	if (check_bool(trackedChanges, nativeTrackedChanges) && 
		check_string<EncodingT>(str, nativeStr))
	{
		res.reset(new WordXMLNodeListInterpreter<EncodingT>(value().appendString(nativeTrackedChanges, nativeStr.c_str())));
	}
	return res;
}

// Supprime du texte.
template <class EncodingT>
void WordXMLNodeInterpreter<EncodingT>::eraseString(const shared_ptr< Base<EncodingT> >& trackedChanges, const shared_ptr< Base<EncodingT> >& pos, const shared_ptr< Base<EncodingT> >& length)
{
	bool nativeTrackedChanges;
	unsigned long nativePos;
	unsigned long nativeLength;
	if (check_bool(trackedChanges, nativeTrackedChanges) && 
		check_numeric(pos, nativePos) && 
		check_numeric(length, nativeLength))
	{
		value().eraseString(nativeTrackedChanges, nativePos, nativeLength);
	}
}

// Insère du texte.
template <class EncodingT>
shared_ptr< Base<EncodingT> > WordXMLNodeInterpreter<EncodingT>::insertString(const shared_ptr< Base<EncodingT> >& trackedChanges, const shared_ptr< Base<EncodingT> >& pos, const shared_ptr< Base<EncodingT> >& str)
{
	shared_ptr< Base<EncodingT> > res(new WordXMLNodeListInterpreter<EncodingT>());
	bool nativeTrackedChanges;
	unsigned long nativePos;
	typename EncodingT::string_t nativeStr;
	if (check_bool(trackedChanges, nativeTrackedChanges) && 
		check_numeric(pos, nativePos) && 
		check_string<EncodingT>(str, nativeStr))
	{
		res.reset(new WordXMLNodeListInterpreter<EncodingT>(value().insertString(nativeTrackedChanges, nativePos, nativeStr.c_str())));
	}
	return res;
}


template <class EncodingT>
bool check_WordXMLNode(shared_ptr< Base<EncodingT> > const& val, WordXMLNode& a)
{
	shared_ptr< WordXMLNodeInterpreter<EncodingT> > value  = dynamic_pointer_cast< WordXMLNodeInterpreter<EncodingT> >(val);
	if (value)
	{
		a = value->getValue();
	}
	else
	{
		Category * logger = &Category::getInstance(LOGNAME);
		logger->errorStream() << "WordXMLNode expected, got " << A(val->getClassName());
	}
	return value;
}

template <class EncodingT>
bool reset_WordXMLNode(shared_ptr< Base<EncodingT> >& val, WordXMLNode const& a)
{
	shared_ptr< WordXMLNodeInterpreter<EncodingT> > value  = dynamic_pointer_cast< WordXMLNodeInterpreter<EncodingT> >(val);
	if (value)
	{
		value->setValue(a);
	}
	else
	{
		Category* logger = &Category::getInstance(LOGNAME);
		logger->errorStream() << "WordXMLNode expected, got " << A(val->getClassName());
	}
	return value;
}

NAMESPACE_END

#undef A
#undef C