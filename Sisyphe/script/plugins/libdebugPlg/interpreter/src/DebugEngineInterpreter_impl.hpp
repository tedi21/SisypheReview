/*
 * DebugEngineInterpreter_impl.hpp
 *
 *
 * @date 21-06-2016
 * @author Teddy DIDE
 * @version 1.00
 * Debug Interpreter generated by gensources.
 */

#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(interp)


template <class EncodingT>
DebugEngineInterpreter<EncodingT>::DebugEngineInterpreter()
{
}

template <class EncodingT>
void DebugEngineInterpreter<EncodingT>::tidyValue()
{
}

template <class EncodingT>
DebugEngineInterpreter<EncodingT>::~DebugEngineInterpreter()
{
	tidyValue();
}

template <class EncodingT>
typename EncodingT::string_t DebugEngineInterpreter<EncodingT>::toString() const
{
	return EncodingT::EMPTY;
}

template <class EncodingT>
shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::clone() const
{
	return shared_ptr< Base<EncodingT> >(new DebugEngineInterpreter<EncodingT>(*this));
}

template <class EncodingT>
typename EncodingT::string_t DebugEngineInterpreter<EncodingT>::getClassName() const
{
	return C("DebugEngine");
}

template <class EncodingT>
shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::invoke(const typename EncodingT::string_t& method, std::vector< shared_ptr< Base<EncodingT> > >& params)
{
	shared_ptr< Base<EncodingT> > obj(new Base<EncodingT>());
	ParameterArray args, ret;
	if (check_parameters_array(params, args))
	{
		if (tryInvoke(this, C("DebugEngine"), method, args, ret))
		{
			find_parameter(ret, FACTORY_RETURN_PARAMETER, obj);
			for (size_t i = 0; i < params.size(); ++i)
			{
				find_parameter(ret, i, params[i]);
			}
		}
		else
		{
			Category* logger = &Category::getInstance(LOGNAME);
			logger->errorStream() << "Unexpected call in DebugEngine, no method \"" << A(method) << "\" exists.";
		}
	}
	return obj;
}

// Initialise le moteur de débogage.
template <class EncodingT>
shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::initialize() const
{
if (m_debugClient == NULL)
  {
    HRESULT hr = DebugCreate(IID_IDebugClient, (void**)&m_debugClient);
    if(SUCCEEDED(hr))
    {  
        hr = m_debugClient->QueryInterface(IID_IDebugControl3, (void**)&m_debugControl);
        if (SUCCEEDED(hr))
        {
            m_eventCallback = new EventCallbacks(m_debugControl);
            hr = m_debugClient->SetEventCallbacks(m_eventCallback);
        }
        hr = m_debugClient->QueryInterface(IID_IDebugSystemObjects, (void**)&m_debugSystemObjects);
        hr = m_debugClient->QueryInterface(IID_IDebugSymbols, (void**)&m_debugSymbols);
    }
  }
  return shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient != NULL));
}

// Libère les objets debug.
template <class EncodingT>
shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::terminate() const
{
if(m_debugSymbols != NULL)
  {
    m_debugSymbols->Release();
    m_debugSymbols = NULL;
  }
  if(m_debugSystemObjects != NULL)
  {
    m_debugSystemObjects->Release();
    m_debugSystemObjects = NULL;
  }
  if(m_debugClient != NULL)
  {
    m_debugClient->EndSession(DEBUG_END_PASSIVE);
    m_debugClient->Release();
    m_debugClient = NULL;
  }
  if(m_debugControl != NULL)
  {
    m_debugControl->Release();
    m_debugControl = NULL;
  }
  delete m_eventCallback;
  m_eventCallback = NULL;
  return shared_ptr< Base<EncodingT> > (new Bool<EncodingT>(m_debugClient == NULL));
}

// Allocate additional memory to the target process.
template <class EncodingT>
shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::dvAlloc(const shared_ptr< Base<EncodingT> >& size)
{
shared_ptr< Base<EncodingT> > res(new Numeric<EncodingT>());
	unsigned long nativeSize;
	if (check_numeric(size, nativeSize))
	{
        unsigned long long hProcess;
        HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
        if (SUCCEEDED(hr))
        {
            res.reset(new Numeric<EncodingT>((int) VirtualAllocEx((HANDLE) hProcess, NULL, nativeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)));
        }
    }
	return res;
}

// Frees a memory allocation owned by the target process.
template <class EncodingT>
shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::dvFree(const shared_ptr< Base<EncodingT> >& baseAddress, const shared_ptr< Base<EncodingT> >& size)
{
shared_ptr< Base<EncodingT> > res(new Bool<EncodingT>(false));
	unsigned long nativeSize;
  int nativeBaseAddress;
	if (check_numeric(baseAddress, nativeBaseAddress) && check_numeric(size, nativeSize))
	{
        unsigned long long hProcess;
        HRESULT hr = m_debugSystemObjects->GetCurrentProcessHandle(&hProcess);
        if (SUCCEEDED(hr))
        {
            res.reset(new Bool<EncodingT>(VirtualFreeEx((HANDLE) hProcess, (LPVOID)nativeBaseAddress, nativeSize, MEM_RELEASE)));
        }
  }
	return res;
}
// Retourne l'objet DebugClient
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugClient() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugClientPtrInterpreter<EncodingT>(m_debugClient));
  }
  
  // Retourne l'objet DebugControl
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugControl() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugControlPtrInterpreter<EncodingT>(m_debugControl));
  }
  
  // Retourne l'objet DebugSystemObjects
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSystemObjects() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugSystemObjectsPtrInterpreter<EncodingT>(m_debugSystemObjects));
  }
 
  // Retourne l'objet DebugSymbols
  template <class EncodingT>
  shared_ptr< Base<EncodingT> > DebugEngineInterpreter<EncodingT>::getDebugSymbols() const
  {
    return shared_ptr< Base<EncodingT> > (new IDebugSymbolsPtrInterpreter<EncodingT>(m_debugSymbols));
  }

NAMESPACE_END

template <class EncodingT>
IDebugClient* interp::DebugEngineInterpreter<EncodingT>::m_debugClient = NULL;
template <class EncodingT>
IDebugControl3* interp::DebugEngineInterpreter<EncodingT>::m_debugControl = NULL;
template <class EncodingT>
EventCallbacks* interp::DebugEngineInterpreter<EncodingT>::m_eventCallback = NULL;
template <class EncodingT>
IDebugSystemObjects* interp::DebugEngineInterpreter<EncodingT>::m_debugSystemObjects = NULL;
template <class EncodingT>
IDebugSymbols* interp::DebugEngineInterpreter<EncodingT>::m_debugSymbols = NULL;

EventCallbacks::EventCallbacks(IDebugControl3 *control)
: m_Control(control)
{
}

STDMETHODIMP_(ULONG) EventCallbacks::AddRef(    THIS )  // event callback method 1
{
       return 1;
}
STDMETHODIMP_(ULONG) EventCallbacks::Release( THIS )  //event callback method 2
{
       return 0;
}
STDMETHODIMP EventCallbacks::Breakpoint( THIS_ IN PDEBUG_BREAKPOINT Bp ) //event callback method 3
{
       return DEBUG_STATUS_BREAK;
}
STDMETHODIMP EventCallbacks::CreateProcess(THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 Handle,
       IN ULONG64 BaseOffset,IN ULONG ModuleSize,IN PCSTR ModuleName,IN PCSTR ImageName,
       IN ULONG CheckSum, IN ULONG TimeDateStamp,IN ULONG64 InitialThreadHandle,
       IN ULONG64 ThreadDataOffset,  IN ULONG64 StartOffset
       ) //event callback method 4  and so on till method 16
{
       HRESULT status = 0; //we are setting a break point in Address Of Entrypoint of the debuggee
       IDebugBreakpoint* breakpoint = NULL;
       if (( status = m_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE,DEBUG_ANY_ID, &breakpoint)) == S_OK)
       {
              if (( status = breakpoint->SetOffset(StartOffset)) == S_OK)
              {
                     if (( status = breakpoint->SetFlags(DEBUG_BREAKPOINT_ENABLED)) == S_OK)
                     {
                            m_Breakpoint.reset(breakpoint);
                            breakpoint->Release();
                     }
              }
       }
       return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP EventCallbacks::CreateThread( THIS_ IN ULONG64  Handle, IN ULONG64  DataOffset, IN ULONG64  StartOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::Exception( THIS_ IN PEXCEPTION_RECORD64 Exception, IN ULONG FirstChance )
{
       return DEBUG_STATUS_BREAK;
}
STDMETHODIMP EventCallbacks::ExitProcess (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ExitThread (THIS_ IN ULONG  ExitCode )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::GetInterestMask( THIS_ OUT PULONG Mask )
{
       *Mask =
              DEBUG_EVENT_BREAKPOINT |
              DEBUG_EVENT_EXCEPTION |
              DEBUG_EVENT_CREATE_THREAD |
              DEBUG_EVENT_EXIT_THREAD |
              DEBUG_EVENT_CREATE_PROCESS |
              DEBUG_EVENT_EXIT_PROCESS |
              DEBUG_EVENT_LOAD_MODULE |
              DEBUG_EVENT_UNLOAD_MODULE |
              DEBUG_EVENT_SYSTEM_ERROR |
              DEBUG_EVENT_SESSION_STATUS |
              DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
              DEBUG_EVENT_CHANGE_ENGINE_STATE |
              DEBUG_EVENT_CHANGE_SYMBOL_STATE;
       return S_OK;
}
STDMETHODIMP EventCallbacks::LoadModule( THIS_ IN ULONG64 ImageFileHandle, IN ULONG64 BaseOffset,
       IN ULONG ModuleSize,IN PCSTR ModuleName, IN PCSTR ImageName, IN ULONG CheckSum, IN ULONG TimeDateStamp )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::SystemError( THIS_ IN ULONG  Error, IN ULONG  Level )
{
       return DEBUG_STATUS_BREAK;
}
STDMETHODIMP EventCallbacks::UnloadModule( THIS_ IN PCSTR  ImageBaseName, IN ULONG64  BaseOffset )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::SessionStatus( THIS_ IN ULONG SessionStatus )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ChangeDebuggeeState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ChangeEngineState( THIS_ IN ULONG Flags, IN ULONG64 Argument )
{
       return DEBUG_STATUS_NO_CHANGE;
}
STDMETHODIMP EventCallbacks::ChangeSymbolState( THIS_ IN ULONG Flags, IN ULONG64 Argument ) // method 16
{
       return DEBUG_STATUS_NO_CHANGE;
}

#undef A
#undef C