/* 
 * debugFileInfo.hpp
 *
 *
 * @date 25-06-2020
 * @author Teddy DIDE
 * @version 1.00
 * cppBase generated by gensources.
 */

#ifndef _DEBUGFILEINFO_HPP_
#define _DEBUGFILEINFO_HPP_

#include <boost/shared_ptr.hpp>
#include <boost/container/vector.hpp>
#include "copy_ptr.h"
#include "config.hpp"
#include "convert.hpp"
#include "encoding.hpp"

#include "cppBaseExport.hpp"
#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(data_access)

template <class EncodingT>
class _DebugFileInfoAccess;

NAMESPACE_END

NAMESPACE_BEGIN(entity)

using namespace log4cpp;
using namespace fctr;
using namespace enc;
using namespace boost;

template <class EncodingT>
class _DebugFunctionInfo;

template <class EncodingT>
class _DebugStubInfo;

template <class EncodingT>
class _TextFile;

/// debugFileInfo table represents file information for debug.
template <class EncodingT>
class  _DebugFileInfo {
private :
	long long	m_identifier;
	boost::shared_ptr< _TextFile<EncodingT> >	m_textFile;
	typename EncodingT::string_t	m_name;
	typename EncodingT::string_t	m_compilandPath;
	boost::container::vector<unsigned char>	m_checksum;
	typedef std::vector< boost::shared_ptr< _DebugFunctionInfo<EncodingT> > >	vector_debugFunctionInfo;
	vector_debugFunctionInfo	m_debugFunctionInfos;
	typedef std::vector< boost::shared_ptr< _DebugStubInfo<EncodingT> > >	vector_debugStubInfo;
	vector_debugStubInfo	m_debugStubInfos;
	Category*	m_logger;

protected :
	friend class data_access::_DebugFileInfoAccess<EncodingT>;

	/** Creates a new element DebugFileInfo.
	@param identifier 
	@param name 
	@param compilandPath 
	@param checksum 
	*/
	_DebugFileInfo(long long identifier,
				const typename EncodingT::string_t& name,
				const typename EncodingT::string_t& compilandPath,
				const boost::container::vector<unsigned char>& checksum)
	: m_identifier(identifier),
	  m_name(name),
	  m_compilandPath(compilandPath),
	  m_checksum(checksum)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugFileInfo "
				<< m_identifier << ' '
				<< A(m_name) << ' '
				<< A(m_compilandPath) << ' ';
	}

	/** Sets a value of the element <i>identifier</i> in DebugFileInfo.
	@param identifier 
	*/
	void setIdentifier(long long identifier)  
	{
		m_identifier = identifier;
	}

public :
	/** Creates a new element DebugFileInfo.
	*/
	_DebugFileInfo()
	: m_identifier(-1),
	  m_name(EncodingT::EMPTY),
	  m_compilandPath(EncodingT::EMPTY)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugFileInfo ";
	}

	/** Creates a new element DebugFileInfo.
	@param name 
	@param compilandPath 
	@param checksum 
	*/
	_DebugFileInfo(const typename EncodingT::string_t& name,
				const typename EncodingT::string_t& compilandPath,
				const boost::container::vector<unsigned char>& checksum)
	: m_identifier(-1),
	  m_name(name),
	  m_compilandPath(compilandPath),
	  m_checksum(checksum)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugFileInfo "
				<< m_identifier << ' '
				<< A(m_name) << ' '
				<< A(m_compilandPath) << ' ';
	}

	/** Returns a const reference to the element <i>identifier</i> in DebugFileInfo.
	@return 
	*/
	long long getIdentifier() const 
	{
		return m_identifier;
	}

	/** Returns a const reference to the element <i>textFile</i> in DebugFileInfo.
	@return 
	*/
	boost::shared_ptr< _TextFile<EncodingT> > getTextFile() const 
	{
		return m_textFile;
	}

	/** Sets a value of the element <i>textFile</i> in DebugFileInfo.
	@param textFile 
	*/
	void setTextFile(boost::shared_ptr< _TextFile<EncodingT> > textFile)  
	{
		m_textFile = textFile;
	}

	/** Returns whether the element <i>textFile</i> in DebugFileInfo is NULL.
	@return True if the element <i>textFile</i> is NULL, false otherwise.
	*/
	bool isNullTextFile() const 
	{
		return !m_textFile;
	}

	/** Removes from DebugFileInfo an element <i>textFile</i>.
	*/
	void eraseTextFile()  
	{
		m_textFile.reset();
	}

	/** Returns a const reference to the element <i>name</i> in DebugFileInfo.
	@return 
	*/
	const typename EncodingT::string_t& getName() const 
	{
		return m_name;
	}

	/** Sets a value of the element <i>name</i> in DebugFileInfo.
	@param name 
	*/
	void setName(const typename EncodingT::string_t& name)  
	{
		m_name = name;
	}

	/** Returns a const reference to the element <i>compilandPath</i> in DebugFileInfo.
	@return 
	*/
	const typename EncodingT::string_t& getCompilandPath() const 
	{
		return m_compilandPath;
	}

	/** Sets a value of the element <i>compilandPath</i> in DebugFileInfo.
	@param compilandPath 
	*/
	void setCompilandPath(const typename EncodingT::string_t& compilandPath)  
	{
		m_compilandPath = compilandPath;
	}

	/** Returns a const reference to the element <i>checksum</i> in DebugFileInfo.
	@return 
	*/
	const boost::container::vector<unsigned char>& getChecksum() const 
	{
		return m_checksum;
	}

	/** Sets a value of the element <i>checksum</i> in DebugFileInfo.
	@param checksum 
	*/
	void setChecksum(const boost::container::vector<unsigned char>& checksum)  
	{
		m_checksum = checksum;
	}

	/// Random access iterator types for DebugFunctionInfo vector.
	typedef typename vector_debugFunctionInfo::iterator	DebugFunctionInfoIterator;
	typedef typename vector_debugFunctionInfo::const_iterator	DebugFunctionInfoConstIterator;

	/// Random access iterator types for DebugStubInfo vector.
	typedef typename vector_debugStubInfo::iterator	DebugStubInfoIterator;
	typedef typename vector_debugStubInfo::const_iterator	DebugStubInfoConstIterator;

	/** Returns an iterator referring to the first element in the vector container DebugFunctionInfo.
	@return An iterator to the beginning of the sequence.
	*/
	DebugFunctionInfoIterator getDebugFunctionInfosBeginning()  
	{
		return m_debugFunctionInfos.begin();
	}

	/** Returns an iterator referring to the past-the-end element in the vector container DebugFunctionInfo.
	@return An iterator to the element past the end of the sequence.
	*/
	DebugFunctionInfoIterator getDebugFunctionInfosEnd()  
	{
		return m_debugFunctionInfos.end();
	}

	/** Returns a const iterator referring to the first element in the vector container DebugFunctionInfo.
	@return A const iterator to the beginning of the sequence.
	*/
	DebugFunctionInfoConstIterator getDebugFunctionInfosBeginning() const 
	{
		return m_debugFunctionInfos.begin();
	}

	/** Returns a const iterator referring to the past-the-end element in the vector container DebugFunctionInfo.
	@return A const iterator to the element past the end of the sequence.
	*/
	DebugFunctionInfoConstIterator getDebugFunctionInfosEnd() const 
	{
		return m_debugFunctionInfos.end();
	}

	/** Returns a reference to the element at position n in the vector DebugFunctionInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _DebugFunctionInfo<EncodingT> >& getDebugFunctionInfoAt(size_t n)  
	{
		return m_debugFunctionInfos.at(n);
	}

	/** Returns a const reference to the element at position n in the vector DebugFunctionInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _DebugFunctionInfo<EncodingT> > getDebugFunctionInfoAt(size_t n) const 
	{
		return m_debugFunctionInfos.at(n);
	}

	/** Returns the number of elements in the vector container DebugFunctionInfo.
	@return The number of elements that conform the vector's content.
	*/
	size_t getDebugFunctionInfosSize() const 
	{
		return m_debugFunctionInfos.size();
	}

	/** Returns whether the vector container DebugFunctionInfo is empty, i.e. whether its size is 0.
	@return True if the vector size is 0, false otherwise.
	*/
	bool isDebugFunctionInfosEmpty() const 
	{
		return m_debugFunctionInfos.empty();
	}

	/** Adds a new element at the end of the vector DebugFunctionInfo, after its current last element. The content of this new element is initialized to a copy of x.
	@param o Value to be copied to the new element.
	*/
	void addDebugFunctionInfo(boost::shared_ptr< _DebugFunctionInfo<EncodingT> > o)  
	{
		m_debugFunctionInfos.push_back(copy_ptr(o));
	}

	/** The vector DebugFunctionInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param o Value to be used to initialize the inserted elements.
	@return An iterator that points to the newly inserted element.
	*/
	DebugFunctionInfoIterator insertDebugFunctionInfo(DebugFunctionInfoIterator pos, boost::shared_ptr< _DebugFunctionInfo<EncodingT> > o)  
	{
		return m_debugFunctionInfos.insert(pos, copy_ptr(o));
	}

	/** The vector DebugFunctionInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param first First iterator specifying a range of elements.
	@param last Last iterator specifying a range of elements. Copies of the elements in the range [first,last) are inserted at position pos.
	*/
	void insertDebugFunctionInfo(DebugFunctionInfoIterator pos, DebugFunctionInfoIterator first, DebugFunctionInfoIterator last)  
	{
		std::transform(first, last, std::inserter(m_debugFunctionInfos, pos), static_cast< boost::shared_ptr< _DebugFunctionInfo<EncodingT> >(*)(boost::shared_ptr< _DebugFunctionInfo<EncodingT> >) >(copy_ptr));
	}

	/** Removes from the vector container DebugFunctionInfo a single element.
	@param pos Iterator pointing to a single element to be removed from the vector.
	*/
	DebugFunctionInfoIterator eraseDebugFunctionInfo(DebugFunctionInfoIterator pos)  
	{
		return m_debugFunctionInfos.erase(pos);
	}

	/** Removes from the vector container DebugFunctionInfo a range of elements ([first,last)).
	@param first First iterator specifying a range within the vector to be removed: [first,last).
	@param last Last iterator specifying a range within the vector to be removed: [first,last).
	*/
	DebugFunctionInfoIterator eraseDebugFunctionInfo(DebugFunctionInfoIterator first, DebugFunctionInfoIterator last)  
	{
		return m_debugFunctionInfos.erase(first, last);
	}

	/** All the elements of the vector are dropped: their destructors are called, and then they are removed from the vector container DebugFunctionInfo, leaving the container with a size of 0.
	*/
	void clearDebugFunctionInfos()  
	{
		m_debugFunctionInfos.clear();
	}

	/** Returns an iterator referring to the first element in the vector container DebugStubInfo.
	@return An iterator to the beginning of the sequence.
	*/
	DebugStubInfoIterator getDebugStubInfosBeginning()  
	{
		return m_debugStubInfos.begin();
	}

	/** Returns an iterator referring to the past-the-end element in the vector container DebugStubInfo.
	@return An iterator to the element past the end of the sequence.
	*/
	DebugStubInfoIterator getDebugStubInfosEnd()  
	{
		return m_debugStubInfos.end();
	}

	/** Returns a const iterator referring to the first element in the vector container DebugStubInfo.
	@return A const iterator to the beginning of the sequence.
	*/
	DebugStubInfoConstIterator getDebugStubInfosBeginning() const 
	{
		return m_debugStubInfos.begin();
	}

	/** Returns a const iterator referring to the past-the-end element in the vector container DebugStubInfo.
	@return A const iterator to the element past the end of the sequence.
	*/
	DebugStubInfoConstIterator getDebugStubInfosEnd() const 
	{
		return m_debugStubInfos.end();
	}

	/** Returns a reference to the element at position n in the vector DebugStubInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _DebugStubInfo<EncodingT> >& getDebugStubInfoAt(size_t n)  
	{
		return m_debugStubInfos.at(n);
	}

	/** Returns a const reference to the element at position n in the vector DebugStubInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _DebugStubInfo<EncodingT> > getDebugStubInfoAt(size_t n) const 
	{
		return m_debugStubInfos.at(n);
	}

	/** Returns the number of elements in the vector container DebugStubInfo.
	@return The number of elements that conform the vector's content.
	*/
	size_t getDebugStubInfosSize() const 
	{
		return m_debugStubInfos.size();
	}

	/** Returns whether the vector container DebugStubInfo is empty, i.e. whether its size is 0.
	@return True if the vector size is 0, false otherwise.
	*/
	bool isDebugStubInfosEmpty() const 
	{
		return m_debugStubInfos.empty();
	}

	/** Adds a new element at the end of the vector DebugStubInfo, after its current last element. The content of this new element is initialized to a copy of x.
	@param o Value to be copied to the new element.
	*/
	void addDebugStubInfo(boost::shared_ptr< _DebugStubInfo<EncodingT> > o)  
	{
		m_debugStubInfos.push_back(copy_ptr(o));
	}

	/** The vector DebugStubInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param o Value to be used to initialize the inserted elements.
	@return An iterator that points to the newly inserted element.
	*/
	DebugStubInfoIterator insertDebugStubInfo(DebugStubInfoIterator pos, boost::shared_ptr< _DebugStubInfo<EncodingT> > o)  
	{
		return m_debugStubInfos.insert(pos, copy_ptr(o));
	}

	/** The vector DebugStubInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param first First iterator specifying a range of elements.
	@param last Last iterator specifying a range of elements. Copies of the elements in the range [first,last) are inserted at position pos.
	*/
	void insertDebugStubInfo(DebugStubInfoIterator pos, DebugStubInfoIterator first, DebugStubInfoIterator last)  
	{
		std::transform(first, last, std::inserter(m_debugStubInfos, pos), static_cast< boost::shared_ptr< _DebugStubInfo<EncodingT> >(*)(boost::shared_ptr< _DebugStubInfo<EncodingT> >) >(copy_ptr));
	}

	/** Removes from the vector container DebugStubInfo a single element.
	@param pos Iterator pointing to a single element to be removed from the vector.
	*/
	DebugStubInfoIterator eraseDebugStubInfo(DebugStubInfoIterator pos)  
	{
		return m_debugStubInfos.erase(pos);
	}

	/** Removes from the vector container DebugStubInfo a range of elements ([first,last)).
	@param first First iterator specifying a range within the vector to be removed: [first,last).
	@param last Last iterator specifying a range within the vector to be removed: [first,last).
	*/
	DebugStubInfoIterator eraseDebugStubInfo(DebugStubInfoIterator first, DebugStubInfoIterator last)  
	{
		return m_debugStubInfos.erase(first, last);
	}

	/** All the elements of the vector are dropped: their destructors are called, and then they are removed from the vector container DebugStubInfo, leaving the container with a size of 0.
	*/
	void clearDebugStubInfos()  
	{
		m_debugStubInfos.clear();
	}

	/** Prints DebugFileInfo object on a C++ stream.
	@param o Reference of C++ stream object.
	@return The reference of C++ stream object.
	*/
	ostream& printConsole(ostream& o) const 
	{
		return o << "DebugFileInfo" << endl
		         << "identifier : " << m_identifier << endl
		         << "name : " << A(m_name) << endl
		         << "compilandPath : " << A(m_compilandPath);
	}

	/** Defines <i> operator<< </i> for DebugFileInfo.
	@param o Reference of C++ stream object.
	@param elem Const reference of DebugFileInfo object.
	@return The reference of C++ stream object.
	*/
	friend ostream& operator<<(ostream& o, const _DebugFileInfo<EncodingT>& elem)  
	{
		return elem.printConsole(o<<"[ ")<<" ]";
	}

	class DebugFileInfoIDEquality;
	class NameEquality;
	class NameInferior;
	class NameSuperior;
	class CompilandPathEquality;
	class CompilandPathInferior;
	class CompilandPathSuperior;
	class ChecksumEquality;
};

typedef _DebugFileInfo<ucs> UniDebugFileInfo;
typedef _DebugFileInfo<ansi> DebugFileInfo;

NAMESPACE_END

#undef C
#undef A

#include "debugFileInfoPredicate.hpp"

#endif
