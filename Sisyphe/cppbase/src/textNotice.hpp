/* 
 * textNotice.hpp
 *
 *
 * @date 28-08-2016
 * @author Teddy DIDE
 * @version 1.00
 * cppBase generated by gensources.
 */

#ifndef _TEXTNOTICE_HPP_
#define _TEXTNOTICE_HPP_

#include <boost/shared_ptr.hpp>
#include <boost/container/vector.hpp>
#include "copy_ptr.h"
#include "config.hpp"
#include "convert.hpp"
#include "encoding.hpp"

#include "cppBaseExport.hpp"
#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(data_access)

template <class EncodingT>
class _TextNoticeAccess;

NAMESPACE_END

NAMESPACE_BEGIN(entity)

using namespace log4cpp;
using namespace fctr;
using namespace enc;
using namespace boost;

template <class EncodingT>
class _TextFile;

/// 
template <class EncodingT>
class  _TextNotice {
private :
	long long	m_rowid;
	typename EncodingT::string_t	m_description;
	typename EncodingT::string_t	m_category;
	int	m_lineNumber;
	boost::shared_ptr< _TextFile<EncodingT> >	m_textFile;
	int	m_startBlock;
	int	m_lengthBlock;
	Category*	m_logger;

protected :
	friend class data_access::_TextNoticeAccess<EncodingT>;

	/** Creates a new element TextNotice.
	@param rowid 
	@param description 
	@param category 
	@param lineNumber 
	@param startBlock 
	@param lengthBlock 
	*/
	_TextNotice(long long rowid,
				const typename EncodingT::string_t& description,
				const typename EncodingT::string_t& category,
				int lineNumber,
				int startBlock,
				int lengthBlock)
	: m_rowid(rowid),
	  m_description(description),
	  m_category(category),
	  m_lineNumber(lineNumber),
	  m_startBlock(startBlock),
	  m_lengthBlock(lengthBlock)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _TextNotice "
				<< m_rowid << ' '
				<< A(m_description) << ' '
				<< A(m_category) << ' '
				<< m_lineNumber << ' '
				<< m_startBlock << ' '
				<< m_lengthBlock << ' ';
	}

	/** Sets a value of the element <i>rowid</i> in TextNotice.
	@param rowid 
	*/
	void setRowid(long long rowid)  
	{
		m_rowid = rowid;
	}

public :
	/** Creates a new element TextNotice.
	*/
	_TextNotice()
	: m_rowid(-1),
	  m_description(EncodingT::EMPTY),
	  m_category(EncodingT::EMPTY),
	  m_lineNumber(0),
	  m_startBlock(0),
	  m_lengthBlock(0)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _TextNotice ";
	}

	/** Creates a new element TextNotice.
	@param description 
	@param category 
	@param lineNumber 
	@param startBlock 
	@param lengthBlock 
	*/
	_TextNotice(const typename EncodingT::string_t& description,
				const typename EncodingT::string_t& category,
				int lineNumber,
				int startBlock,
				int lengthBlock)
	: m_rowid(-1),
	  m_description(description),
	  m_category(category),
	  m_lineNumber(lineNumber),
	  m_startBlock(startBlock),
	  m_lengthBlock(lengthBlock)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _TextNotice "
				<< m_rowid << ' '
				<< A(m_description) << ' '
				<< A(m_category) << ' '
				<< m_lineNumber << ' '
				<< m_startBlock << ' '
				<< m_lengthBlock << ' ';
	}

	/** Creates a copy of elem as the content for the TextNotice object.
	@param elem A TextNotice object containing elements of the same type.
	*/
	_TextNotice(const _TextNotice<EncodingT>& elem)
	: m_rowid(elem.m_rowid),
	  m_description(elem.m_description),
	  m_category(elem.m_category),
	  m_lineNumber(elem.m_lineNumber),
	  m_textFile(elem.m_textFile),
	  m_startBlock(elem.m_startBlock),
	  m_lengthBlock(elem.m_lengthBlock)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _TextNotice " << ": copy";
	}

	/** Assigns a copy of elem as the new content for the TextNotice object.
	@param elem A TextNotice object containing elements of the same type.
	@return *this
	*/
	_TextNotice<EncodingT>& operator=(const _TextNotice<EncodingT>& elem)  
	{
		m_rowid = elem.m_rowid;
		m_description = elem.m_description;
		m_category = elem.m_category;
		m_lineNumber = elem.m_lineNumber;
		m_textFile = elem.m_textFile;
		m_startBlock = elem.m_startBlock;
		m_lengthBlock = elem.m_lengthBlock;
		return *this;
	}

	/** Returns a const reference to the element <i>rowid</i> in TextNotice.
	@return 
	*/
	long long getRowid() const 
	{
		return m_rowid;
	}

	/** Returns a const reference to the element <i>description</i> in TextNotice.
	@return 
	*/
	const typename EncodingT::string_t& getDescription() const 
	{
		return m_description;
	}

	/** Sets a value of the element <i>description</i> in TextNotice.
	@param description 
	*/
	void setDescription(const typename EncodingT::string_t& description)  
	{
		m_description = description;
	}

	/** Returns a const reference to the element <i>category</i> in TextNotice.
	@return 
	*/
	const typename EncodingT::string_t& getCategory() const 
	{
		return m_category;
	}

	/** Sets a value of the element <i>category</i> in TextNotice.
	@param category 
	*/
	void setCategory(const typename EncodingT::string_t& category)  
	{
		m_category = category;
	}

	/** Returns a const reference to the element <i>lineNumber</i> in TextNotice.
	@return 
	*/
	int getLineNumber() const 
	{
		return m_lineNumber;
	}

	/** Sets a value of the element <i>lineNumber</i> in TextNotice.
	@param lineNumber 
	*/
	void setLineNumber(int lineNumber)  
	{
		m_lineNumber = lineNumber;
	}

	/** Returns a const reference to the element <i>textFile</i> in TextNotice.
	@return 
	*/
	boost::shared_ptr< _TextFile<EncodingT> > getTextFile() const 
	{
		return m_textFile;
	}

	/** Sets a value of the element <i>textFile</i> in TextNotice.
	@param textFile 
	*/
	void setTextFile(boost::shared_ptr< _TextFile<EncodingT> > textFile)  
	{
		m_textFile = textFile;
	}

	/** Returns whether the element <i>textFile</i> in TextNotice is NULL.
	@return True if the element <i>textFile</i> is NULL, false otherwise.
	*/
	bool isNullTextFile() const 
	{
		return !m_textFile;
	}

	/** Removes from TextNotice an element <i>textFile</i>.
	*/
	void eraseTextFile()  
	{
		m_textFile.reset();
	}

	/** Returns a const reference to the element <i>startBlock</i> in TextNotice.
	@return 
	*/
	int getStartBlock() const 
	{
		return m_startBlock;
	}

	/** Sets a value of the element <i>startBlock</i> in TextNotice.
	@param startBlock 
	*/
	void setStartBlock(int startBlock)  
	{
		m_startBlock = startBlock;
	}

	/** Returns a const reference to the element <i>lengthBlock</i> in TextNotice.
	@return 
	*/
	int getLengthBlock() const 
	{
		return m_lengthBlock;
	}

	/** Sets a value of the element <i>lengthBlock</i> in TextNotice.
	@param lengthBlock 
	*/
	void setLengthBlock(int lengthBlock)  
	{
		m_lengthBlock = lengthBlock;
	}

	/** Prints TextNotice object on a C++ stream.
	@param o Reference of C++ stream object.
	@return The reference of C++ stream object.
	*/
	ostream& printConsole(ostream& o) const 
	{
		return o << "TextNotice" << endl
		         << "rowid : " << m_rowid << endl
		         << "description : " << A(m_description) << endl
		         << "category : " << A(m_category) << endl
		         << "lineNumber : " << m_lineNumber << endl
		         << "startBlock : " << m_startBlock << endl
		         << "lengthBlock : " << m_lengthBlock;
	}

	/** Defines <i> operator<< </i> for TextNotice.
	@param o Reference of C++ stream object.
	@param elem Const reference of TextNotice object.
	@return The reference of C++ stream object.
	*/
	friend ostream& operator<<(ostream& o, const _TextNotice<EncodingT>& elem)  
	{
		return elem.printConsole(o<<"[ ")<<" ]";
	}

	class TextNoticeIDEquality;
	class DescriptionEquality;
	class DescriptionInferior;
	class DescriptionSuperior;
	class CategoryEquality;
	class CategoryInferior;
	class CategorySuperior;
	class LineNumberEquality;
	class LineNumberInferior;
	class LineNumberSuperior;
	class StartBlockEquality;
	class StartBlockInferior;
	class StartBlockSuperior;
	class LengthBlockEquality;
	class LengthBlockInferior;
	class LengthBlockSuperior;
};

typedef _TextNotice<ucs> UniTextNotice;
typedef _TextNotice<ansi> TextNotice;

NAMESPACE_END

#undef C
#undef A

#include "textNoticePredicate.hpp"

#endif
