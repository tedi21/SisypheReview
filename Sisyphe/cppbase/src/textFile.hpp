/* 
 * textFile.hpp
 *
 *
 * @date 14-07-2020
 * @author Teddy DIDE
 * @version 1.00
 * cppBase generated by gensources.
 */

#ifndef _TEXTFILE_HPP_
#define _TEXTFILE_HPP_

#include <boost/shared_ptr.hpp>
#include <boost/container/vector.hpp>
#include "copy_ptr.h"
#include "config.hpp"
#include "convert.hpp"
#include "encoding.hpp"

#include "cppBaseExport.hpp"
#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(data_access)

template <class EncodingT>
class _TextFileAccess;

NAMESPACE_END

NAMESPACE_BEGIN(entity)

using namespace log4cpp;
using namespace fctr;
using namespace enc;
using namespace boost;

template <class EncodingT>
class _CppFile;

template <class EncodingT>
class _DebugFileInfo;

/// Creation Virtual Table________________Table using FTS4 describes data type for source generation. These information are not used by sqlite.textFile table represents a text file
template <class EncodingT>
class  _TextFile {
private :
	long long	m_rowid;
	typename EncodingT::string_t	m_content;
	typedef std::vector< boost::shared_ptr< _CppFile<EncodingT> > >	vector_cppFile;
	vector_cppFile	m_cppFiles;
	typedef std::vector< boost::shared_ptr< _DebugFileInfo<EncodingT> > >	vector_debugFileInfo;
	vector_debugFileInfo	m_debugFileInfos;
	Category*	m_logger;

protected :
	friend class data_access::_TextFileAccess<EncodingT>;

	/** Creates a new element TextFile.
	@param rowid 
	@param content 
	*/
	_TextFile(long long rowid,
				const typename EncodingT::string_t& content)
	: m_rowid(rowid),
	  m_content(content)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _TextFile "
				<< m_rowid << ' '
				<< A(m_content) << ' ';
	}

	/** Sets a value of the element <i>rowid</i> in TextFile.
	@param rowid 
	*/
	void setRowid(long long rowid)  
	{
		m_rowid = rowid;
	}

public :
	/** Creates a new element TextFile.
	*/
	_TextFile()
	: m_rowid(-1),
	  m_content(EncodingT::EMPTY)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _TextFile ";
	}

	/** Creates a new element TextFile.
	@param content 
	*/
	_TextFile(const typename EncodingT::string_t& content)
	: m_rowid(-1),
	  m_content(content)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _TextFile "
				<< m_rowid << ' '
				<< A(m_content) << ' ';
	}

	/** Returns a const reference to the element <i>rowid</i> in TextFile.
	@return 
	*/
	long long getRowid() const 
	{
		return m_rowid;
	}

	/** Returns a const reference to the element <i>content</i> in TextFile.
	@return 
	*/
	const typename EncodingT::string_t& getContent() const 
	{
		return m_content;
	}

	/** Sets a value of the element <i>content</i> in TextFile.
	@param content 
	*/
	void setContent(const typename EncodingT::string_t& content)  
	{
		m_content = content;
	}

	/// Random access iterator types for CppFile vector.
	typedef typename vector_cppFile::iterator	CppFileIterator;
	typedef typename vector_cppFile::const_iterator	CppFileConstIterator;

	/// Random access iterator types for DebugFileInfo vector.
	typedef typename vector_debugFileInfo::iterator	DebugFileInfoIterator;
	typedef typename vector_debugFileInfo::const_iterator	DebugFileInfoConstIterator;

	/** Returns an iterator referring to the first element in the vector container CppFile.
	@return An iterator to the beginning of the sequence.
	*/
	CppFileIterator getCppFilesBeginning()  
	{
		return m_cppFiles.begin();
	}

	/** Returns an iterator referring to the past-the-end element in the vector container CppFile.
	@return An iterator to the element past the end of the sequence.
	*/
	CppFileIterator getCppFilesEnd()  
	{
		return m_cppFiles.end();
	}

	/** Returns a const iterator referring to the first element in the vector container CppFile.
	@return A const iterator to the beginning of the sequence.
	*/
	CppFileConstIterator getCppFilesBeginning() const 
	{
		return m_cppFiles.begin();
	}

	/** Returns a const iterator referring to the past-the-end element in the vector container CppFile.
	@return A const iterator to the element past the end of the sequence.
	*/
	CppFileConstIterator getCppFilesEnd() const 
	{
		return m_cppFiles.end();
	}

	/** Returns a reference to the element at position n in the vector CppFile.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _CppFile<EncodingT> >& getCppFileAt(size_t n)  
	{
		return m_cppFiles.at(n);
	}

	/** Returns a const reference to the element at position n in the vector CppFile.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _CppFile<EncodingT> > getCppFileAt(size_t n) const 
	{
		return m_cppFiles.at(n);
	}

	/** Returns the number of elements in the vector container CppFile.
	@return The number of elements that conform the vector's content.
	*/
	size_t getCppFilesSize() const 
	{
		return m_cppFiles.size();
	}

	/** Returns whether the vector container CppFile is empty, i.e. whether its size is 0.
	@return True if the vector size is 0, false otherwise.
	*/
	bool isCppFilesEmpty() const 
	{
		return m_cppFiles.empty();
	}

	/** Adds a new element at the end of the vector CppFile, after its current last element. The content of this new element is initialized to a copy of x.
	@param o Value to be copied to the new element.
	*/
	void addCppFile(boost::shared_ptr< _CppFile<EncodingT> > o)  
	{
		m_cppFiles.push_back(copy_ptr(o));
	}

	/** The vector CppFile is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param o Value to be used to initialize the inserted elements.
	@return An iterator that points to the newly inserted element.
	*/
	CppFileIterator insertCppFile(CppFileIterator pos, boost::shared_ptr< _CppFile<EncodingT> > o)  
	{
		return m_cppFiles.insert(pos, copy_ptr(o));
	}

	/** The vector CppFile is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param first First iterator specifying a range of elements.
	@param last Last iterator specifying a range of elements. Copies of the elements in the range [first,last) are inserted at position pos.
	*/
	void insertCppFile(CppFileIterator pos, CppFileIterator first, CppFileIterator last)  
	{
		std::transform(first, last, std::inserter(m_cppFiles, pos), static_cast< boost::shared_ptr< _CppFile<EncodingT> >(*)(boost::shared_ptr< _CppFile<EncodingT> >) >(copy_ptr));
	}

	/** Removes from the vector container CppFile a single element.
	@param pos Iterator pointing to a single element to be removed from the vector.
	*/
	CppFileIterator eraseCppFile(CppFileIterator pos)  
	{
		return m_cppFiles.erase(pos);
	}

	/** Removes from the vector container CppFile a range of elements ([first,last)).
	@param first First iterator specifying a range within the vector to be removed: [first,last).
	@param last Last iterator specifying a range within the vector to be removed: [first,last).
	*/
	CppFileIterator eraseCppFile(CppFileIterator first, CppFileIterator last)  
	{
		return m_cppFiles.erase(first, last);
	}

	/** All the elements of the vector are dropped: their destructors are called, and then they are removed from the vector container CppFile, leaving the container with a size of 0.
	*/
	void clearCppFiles()  
	{
		m_cppFiles.clear();
	}

	/** Returns an iterator referring to the first element in the vector container DebugFileInfo.
	@return An iterator to the beginning of the sequence.
	*/
	DebugFileInfoIterator getDebugFileInfosBeginning()  
	{
		return m_debugFileInfos.begin();
	}

	/** Returns an iterator referring to the past-the-end element in the vector container DebugFileInfo.
	@return An iterator to the element past the end of the sequence.
	*/
	DebugFileInfoIterator getDebugFileInfosEnd()  
	{
		return m_debugFileInfos.end();
	}

	/** Returns a const iterator referring to the first element in the vector container DebugFileInfo.
	@return A const iterator to the beginning of the sequence.
	*/
	DebugFileInfoConstIterator getDebugFileInfosBeginning() const 
	{
		return m_debugFileInfos.begin();
	}

	/** Returns a const iterator referring to the past-the-end element in the vector container DebugFileInfo.
	@return A const iterator to the element past the end of the sequence.
	*/
	DebugFileInfoConstIterator getDebugFileInfosEnd() const 
	{
		return m_debugFileInfos.end();
	}

	/** Returns a reference to the element at position n in the vector DebugFileInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _DebugFileInfo<EncodingT> >& getDebugFileInfoAt(size_t n)  
	{
		return m_debugFileInfos.at(n);
	}

	/** Returns a const reference to the element at position n in the vector DebugFileInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	boost::shared_ptr< _DebugFileInfo<EncodingT> > getDebugFileInfoAt(size_t n) const 
	{
		return m_debugFileInfos.at(n);
	}

	/** Returns the number of elements in the vector container DebugFileInfo.
	@return The number of elements that conform the vector's content.
	*/
	size_t getDebugFileInfosSize() const 
	{
		return m_debugFileInfos.size();
	}

	/** Returns whether the vector container DebugFileInfo is empty, i.e. whether its size is 0.
	@return True if the vector size is 0, false otherwise.
	*/
	bool isDebugFileInfosEmpty() const 
	{
		return m_debugFileInfos.empty();
	}

	/** Adds a new element at the end of the vector DebugFileInfo, after its current last element. The content of this new element is initialized to a copy of x.
	@param o Value to be copied to the new element.
	*/
	void addDebugFileInfo(boost::shared_ptr< _DebugFileInfo<EncodingT> > o)  
	{
		m_debugFileInfos.push_back(copy_ptr(o));
	}

	/** The vector DebugFileInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param o Value to be used to initialize the inserted elements.
	@return An iterator that points to the newly inserted element.
	*/
	DebugFileInfoIterator insertDebugFileInfo(DebugFileInfoIterator pos, boost::shared_ptr< _DebugFileInfo<EncodingT> > o)  
	{
		return m_debugFileInfos.insert(pos, copy_ptr(o));
	}

	/** The vector DebugFileInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param first First iterator specifying a range of elements.
	@param last Last iterator specifying a range of elements. Copies of the elements in the range [first,last) are inserted at position pos.
	*/
	void insertDebugFileInfo(DebugFileInfoIterator pos, DebugFileInfoIterator first, DebugFileInfoIterator last)  
	{
		std::transform(first, last, std::inserter(m_debugFileInfos, pos), static_cast< boost::shared_ptr< _DebugFileInfo<EncodingT> >(*)(boost::shared_ptr< _DebugFileInfo<EncodingT> >) >(copy_ptr));
	}

	/** Removes from the vector container DebugFileInfo a single element.
	@param pos Iterator pointing to a single element to be removed from the vector.
	*/
	DebugFileInfoIterator eraseDebugFileInfo(DebugFileInfoIterator pos)  
	{
		return m_debugFileInfos.erase(pos);
	}

	/** Removes from the vector container DebugFileInfo a range of elements ([first,last)).
	@param first First iterator specifying a range within the vector to be removed: [first,last).
	@param last Last iterator specifying a range within the vector to be removed: [first,last).
	*/
	DebugFileInfoIterator eraseDebugFileInfo(DebugFileInfoIterator first, DebugFileInfoIterator last)  
	{
		return m_debugFileInfos.erase(first, last);
	}

	/** All the elements of the vector are dropped: their destructors are called, and then they are removed from the vector container DebugFileInfo, leaving the container with a size of 0.
	*/
	void clearDebugFileInfos()  
	{
		m_debugFileInfos.clear();
	}

	/** Prints TextFile object on a C++ stream.
	@param o Reference of C++ stream object.
	@return The reference of C++ stream object.
	*/
	ostream& printConsole(ostream& o) const 
	{
		return o << "TextFile" << endl
		         << "rowid : " << m_rowid << endl
		         << "content : " << A(m_content);
	}

	/** Defines <i> operator<< </i> for TextFile.
	@param o Reference of C++ stream object.
	@param elem Const reference of TextFile object.
	@return The reference of C++ stream object.
	*/
	friend ostream& operator<<(ostream& o, const _TextFile<EncodingT>& elem)  
	{
		return elem.printConsole(o<<"[ ")<<" ]";
	}

	class TextFileIDEquality;
	class ContentEquality;
	class ContentInferior;
	class ContentSuperior;
};

typedef _TextFile<ucs> UniTextFile;
typedef _TextFile<ansi> TextFile;

NAMESPACE_END

#undef C
#undef A

#include "textFilePredicate.hpp"

#endif
