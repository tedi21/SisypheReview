/* 
 * debugFunctionInfo.hpp
 *
 *
 * @date 21-06-2016
 * @author Teddy DIDE
 * @version 1.00
 * cppBase generated by gensources.
 */

#ifndef _DEBUGFUNCTIONINFO_HPP_
#define _DEBUGFUNCTIONINFO_HPP_

#include <boost/shared_ptr.hpp>
#include <boost/container/vector.hpp>
#include "copy_ptr.h"
#include "config.hpp"
#include "convert.hpp"
#include "encoding.hpp"

#include "cppBaseExport.hpp"
#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(data_access)

template <class EncodingT>
class _DebugFunctionInfoAccess;

NAMESPACE_END

NAMESPACE_BEGIN(entity)

using namespace log4cpp;
using namespace fctr;
using namespace enc;
using namespace boost;

template <class EncodingT>
class _DebugVariableInfo;

template <class EncodingT>
class _CppFunction;

/// debugFunctionInfo table represents function information for debug.
template <class EncodingT>
class  _DebugFunctionInfo {
private :
	int	m_identifier;
	int	m_lineNumber;
	int	m_address;
	int	m_debugStart;
	int	m_debugEnd;
	shared_ptr< _CppFunction<EncodingT> >	m_cppFunction;
	typedef std::vector< shared_ptr< _DebugVariableInfo<EncodingT> > >	vector_debugVariableInfo;
	vector_debugVariableInfo	m_debugVariableInfos;
	Category*	m_logger;

protected :
	friend class data_access::_DebugFunctionInfoAccess<EncodingT>;

	/** Creates a new element DebugFunctionInfo.
	@param identifier 
	@param lineNumber 
	@param address 
	@param debugStart 
	@param debugEnd 
	*/
	_DebugFunctionInfo(int identifier,
				int lineNumber,
				int address,
				int debugStart,
				int debugEnd)
	: m_identifier(identifier),
	  m_lineNumber(lineNumber),
	  m_address(address),
	  m_debugStart(debugStart),
	  m_debugEnd(debugEnd)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugFunctionInfo "
				<< m_identifier << ' '
				<< m_lineNumber << ' '
				<< m_address << ' '
				<< m_debugStart << ' '
				<< m_debugEnd << ' ';
	}

	/** Sets a value of the element <i>identifier</i> in DebugFunctionInfo.
	@param identifier 
	*/
	void setIdentifier(int identifier)  
	{
		m_identifier = identifier;
	}

public :
	/** Creates a new element DebugFunctionInfo.
	*/
	_DebugFunctionInfo()
	: m_identifier(-1),
	  m_lineNumber(0),
	  m_address(0),
	  m_debugStart(0),
	  m_debugEnd(0)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugFunctionInfo ";
	}

	/** Creates a new element DebugFunctionInfo.
	@param lineNumber 
	@param address 
	@param debugStart 
	@param debugEnd 
	*/
	_DebugFunctionInfo(int lineNumber,
				int address,
				int debugStart,
				int debugEnd)
	: m_identifier(-1),
	  m_lineNumber(lineNumber),
	  m_address(address),
	  m_debugStart(debugStart),
	  m_debugEnd(debugEnd)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugFunctionInfo "
				<< m_identifier << ' '
				<< m_lineNumber << ' '
				<< m_address << ' '
				<< m_debugStart << ' '
				<< m_debugEnd << ' ';
	}

	/** Creates a copy of elem as the content for the DebugFunctionInfo object.
	@param elem A DebugFunctionInfo object containing elements of the same type.
	*/
	_DebugFunctionInfo(const _DebugFunctionInfo<EncodingT>& elem)
	: m_identifier(elem.m_identifier),
	  m_lineNumber(elem.m_lineNumber),
	  m_address(elem.m_address),
	  m_debugStart(elem.m_debugStart),
	  m_debugEnd(elem.m_debugEnd),
	  m_cppFunction(elem.m_cppFunction),
	  m_debugVariableInfos(copy_ptr(elem.m_debugVariableInfos))
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugFunctionInfo " << ": copy";
	}

	/** Assigns a copy of elem as the new content for the DebugFunctionInfo object.
	@param elem A DebugFunctionInfo object containing elements of the same type.
	@return *this
	*/
	_DebugFunctionInfo<EncodingT>& operator=(const _DebugFunctionInfo<EncodingT>& elem)  
	{
		m_identifier = elem.m_identifier;
		m_lineNumber = elem.m_lineNumber;
		m_address = elem.m_address;
		m_debugStart = elem.m_debugStart;
		m_debugEnd = elem.m_debugEnd;
		m_cppFunction = elem.m_cppFunction;
		m_debugVariableInfos = copy_ptr(elem.m_debugVariableInfos);
		return *this;
	}

	/** Returns a const reference to the element <i>identifier</i> in DebugFunctionInfo.
	@return 
	*/
	int getIdentifier() const 
	{
		return m_identifier;
	}

	/** Returns a const reference to the element <i>lineNumber</i> in DebugFunctionInfo.
	@return 
	*/
	int getLineNumber() const 
	{
		return m_lineNumber;
	}

	/** Sets a value of the element <i>lineNumber</i> in DebugFunctionInfo.
	@param lineNumber 
	*/
	void setLineNumber(int lineNumber)  
	{
		m_lineNumber = lineNumber;
	}

	/** Returns a const reference to the element <i>address</i> in DebugFunctionInfo.
	@return 
	*/
	int getAddress() const 
	{
		return m_address;
	}

	/** Sets a value of the element <i>address</i> in DebugFunctionInfo.
	@param address 
	*/
	void setAddress(int address)  
	{
		m_address = address;
	}

	/** Returns a const reference to the element <i>debugStart</i> in DebugFunctionInfo.
	@return 
	*/
	int getDebugStart() const 
	{
		return m_debugStart;
	}

	/** Sets a value of the element <i>debugStart</i> in DebugFunctionInfo.
	@param debugStart 
	*/
	void setDebugStart(int debugStart)  
	{
		m_debugStart = debugStart;
	}

	/** Returns a const reference to the element <i>debugEnd</i> in DebugFunctionInfo.
	@return 
	*/
	int getDebugEnd() const 
	{
		return m_debugEnd;
	}

	/** Sets a value of the element <i>debugEnd</i> in DebugFunctionInfo.
	@param debugEnd 
	*/
	void setDebugEnd(int debugEnd)  
	{
		m_debugEnd = debugEnd;
	}

	/** Returns a const reference to the element <i>cppFunction</i> in DebugFunctionInfo.
	@return 
	*/
	shared_ptr< _CppFunction<EncodingT> > getCppFunction() const 
	{
		return m_cppFunction;
	}

	/** Sets a value of the element <i>cppFunction</i> in DebugFunctionInfo.
	@param cppFunction 
	*/
	void setCppFunction(shared_ptr< _CppFunction<EncodingT> > cppFunction)  
	{
		m_cppFunction = cppFunction;
	}

	/** Returns whether the element <i>cppFunction</i> in DebugFunctionInfo is NULL.
	@return True if the element <i>cppFunction</i> is NULL, false otherwise.
	*/
	bool isNullCppFunction() const 
	{
		return !m_cppFunction;
	}

	/** Removes from DebugFunctionInfo an element <i>cppFunction</i>.
	*/
	void eraseCppFunction()  
	{
		m_cppFunction.reset();
	}

	/// Random access iterator types for DebugVariableInfo vector.
	typedef typename vector_debugVariableInfo::iterator	DebugVariableInfoIterator;
	typedef typename vector_debugVariableInfo::const_iterator	DebugVariableInfoConstIterator;

	/** Returns an iterator referring to the first element in the vector container DebugVariableInfo.
	@return An iterator to the beginning of the sequence.
	*/
	DebugVariableInfoIterator getDebugVariableInfosBeginning()  
	{
		return m_debugVariableInfos.begin();
	}

	/** Returns an iterator referring to the past-the-end element in the vector container DebugVariableInfo.
	@return An iterator to the element past the end of the sequence.
	*/
	DebugVariableInfoIterator getDebugVariableInfosEnd()  
	{
		return m_debugVariableInfos.end();
	}

	/** Returns a const iterator referring to the first element in the vector container DebugVariableInfo.
	@return A const iterator to the beginning of the sequence.
	*/
	DebugVariableInfoConstIterator getDebugVariableInfosBeginning() const 
	{
		return m_debugVariableInfos.begin();
	}

	/** Returns a const iterator referring to the past-the-end element in the vector container DebugVariableInfo.
	@return A const iterator to the element past the end of the sequence.
	*/
	DebugVariableInfoConstIterator getDebugVariableInfosEnd() const 
	{
		return m_debugVariableInfos.end();
	}

	/** Returns a reference to the element at position n in the vector DebugVariableInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	shared_ptr< _DebugVariableInfo<EncodingT> >& getDebugVariableInfoAt(size_t n)  
	{
		return m_debugVariableInfos.at(n);
	}

	/** Returns a const reference to the element at position n in the vector DebugVariableInfo.
	@param n Position of an element in the vector.
	@return The element at the specified position in the vector.
	*/
	shared_ptr< _DebugVariableInfo<EncodingT> > getDebugVariableInfoAt(size_t n) const 
	{
		return m_debugVariableInfos.at(n);
	}

	/** Returns the number of elements in the vector container DebugVariableInfo.
	@return The number of elements that conform the vector's content.
	*/
	size_t getDebugVariableInfosSize() const 
	{
		return m_debugVariableInfos.size();
	}

	/** Returns whether the vector container DebugVariableInfo is empty, i.e. whether its size is 0.
	@return True if the vector size is 0, false otherwise.
	*/
	bool isDebugVariableInfosEmpty() const 
	{
		return m_debugVariableInfos.empty();
	}

	/** Adds a new element at the end of the vector DebugVariableInfo, after its current last element. The content of this new element is initialized to a copy of x.
	@param o Value to be copied to the new element.
	*/
	void addDebugVariableInfo(shared_ptr< _DebugVariableInfo<EncodingT> > o)  
	{
		m_debugVariableInfos.push_back(copy_ptr(o));
	}

	/** The vector DebugVariableInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param o Value to be used to initialize the inserted elements.
	@return An iterator that points to the newly inserted element.
	*/
	DebugVariableInfoIterator insertDebugVariableInfo(DebugVariableInfoIterator pos, shared_ptr< _DebugVariableInfo<EncodingT> > o)  
	{
		return m_debugVariableInfos.insert(pos, copy_ptr(o));
	}

	/** The vector DebugVariableInfo is extended by inserting new elements before the element at position pos.
	@param pos Position in the vector where the new elements are inserted.
	@param first First iterator specifying a range of elements.
	@param last Last iterator specifying a range of elements. Copies of the elements in the range [first,last) are inserted at position pos.
	*/
	void insertDebugVariableInfo(DebugVariableInfoIterator pos, DebugVariableInfoIterator first, DebugVariableInfoIterator last)  
	{
		std::transform(first, last, std::inserter(m_debugVariableInfos, pos), static_cast< shared_ptr< _DebugVariableInfo<EncodingT> >(*)(shared_ptr< _DebugVariableInfo<EncodingT> >) >(copy_ptr));
	}

	/** Removes from the vector container DebugVariableInfo a single element.
	@param pos Iterator pointing to a single element to be removed from the vector.
	*/
	DebugVariableInfoIterator eraseDebugVariableInfo(DebugVariableInfoIterator pos)  
	{
		return m_debugVariableInfos.erase(pos);
	}

	/** Removes from the vector container DebugVariableInfo a range of elements ([first,last)).
	@param first First iterator specifying a range within the vector to be removed: [first,last).
	@param last Last iterator specifying a range within the vector to be removed: [first,last).
	*/
	DebugVariableInfoIterator eraseDebugVariableInfo(DebugVariableInfoIterator first, DebugVariableInfoIterator last)  
	{
		return m_debugVariableInfos.erase(first, last);
	}

	/** All the elements of the vector are dropped: their destructors are called, and then they are removed from the vector container DebugVariableInfo, leaving the container with a size of 0.
	*/
	void clearDebugVariableInfos()  
	{
		m_debugVariableInfos.clear();
	}

	/** Prints DebugFunctionInfo object on a C++ stream.
	@param o Reference of C++ stream object.
	@return The reference of C++ stream object.
	*/
	ostream& printConsole(ostream& o) const 
	{
		return o << "DebugFunctionInfo" << endl
		         << "identifier : " << m_identifier << endl
		         << "lineNumber : " << m_lineNumber << endl
		         << "address : " << m_address << endl
		         << "debugStart : " << m_debugStart << endl
		         << "debugEnd : " << m_debugEnd;
	}

	/** Defines <i> operator<< </i> for DebugFunctionInfo.
	@param o Reference of C++ stream object.
	@param elem Const reference of DebugFunctionInfo object.
	@return The reference of C++ stream object.
	*/
	friend ostream& operator<<(ostream& o, const _DebugFunctionInfo<EncodingT>& elem)  
	{
		return elem.printConsole(o<<"[ ")<<" ]";
	}

	class DebugFunctionInfoIDEquality;
	class LineNumberEquality;
	class LineNumberInferior;
	class LineNumberSuperior;
	class AddressEquality;
	class AddressInferior;
	class AddressSuperior;
	class DebugStartEquality;
	class DebugStartInferior;
	class DebugStartSuperior;
	class DebugEndEquality;
	class DebugEndInferior;
	class DebugEndSuperior;
};

typedef _DebugFunctionInfo<ucs> UniDebugFunctionInfo;
typedef _DebugFunctionInfo<ansi> DebugFunctionInfo;

NAMESPACE_END

#undef C
#undef A

#include "debugFunctionInfoPredicate.hpp"

#endif
