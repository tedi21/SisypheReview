/* 
 * debugVariableInfo.hpp
 *
 *
 * @date 28-08-2016
 * @author Teddy DIDE
 * @version 1.00
 * cppBase generated by gensources.
 */

#ifndef _DEBUGVARIABLEINFO_HPP_
#define _DEBUGVARIABLEINFO_HPP_

#include <boost/shared_ptr.hpp>
#include <boost/container/vector.hpp>
#include "copy_ptr.h"
#include "config.hpp"
#include "convert.hpp"
#include "encoding.hpp"

#include "cppBaseExport.hpp"
#define A(str) encode<EncodingT,ansi>(str)
#define C(str) encode<ansi,EncodingT>(str)

NAMESPACE_BEGIN(data_access)

template <class EncodingT>
class _DebugVariableInfoAccess;

NAMESPACE_END

NAMESPACE_BEGIN(entity)

using namespace log4cpp;
using namespace fctr;
using namespace enc;
using namespace boost;

template <class EncodingT>
class _DebugFunctionInfo;

/// debugVariableInfo table represents variable information for debug.
template <class EncodingT>
class  _DebugVariableInfo {
private :
	int	m_identifier;
	typename EncodingT::string_t	m_category;
	typename EncodingT::string_t	m_debugType;
	typename EncodingT::string_t	m_name;
	typename EncodingT::string_t	m_textValue;
	boost::shared_ptr< _DebugFunctionInfo<EncodingT> >	m_debugFunctionInfo;
	Category*	m_logger;

protected :
	friend class data_access::_DebugVariableInfoAccess<EncodingT>;

	/** Creates a new element DebugVariableInfo.
	@param identifier 
	@param category 
	@param debugType 
	@param name 
	@param textValue 
	*/
	_DebugVariableInfo(int identifier,
				const typename EncodingT::string_t& category,
				const typename EncodingT::string_t& debugType,
				const typename EncodingT::string_t& name,
				const typename EncodingT::string_t& textValue)
	: m_identifier(identifier),
	  m_category(category),
	  m_debugType(debugType),
	  m_name(name),
	  m_textValue(textValue)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugVariableInfo "
				<< m_identifier << ' '
				<< A(m_category) << ' '
				<< A(m_debugType) << ' '
				<< A(m_name) << ' '
				<< A(m_textValue) << ' ';
	}

	/** Sets a value of the element <i>identifier</i> in DebugVariableInfo.
	@param identifier 
	*/
	void setIdentifier(int identifier)  
	{
		m_identifier = identifier;
	}

public :
	/** Creates a new element DebugVariableInfo.
	*/
	_DebugVariableInfo()
	: m_identifier(-1),
	  m_category(EncodingT::EMPTY),
	  m_debugType(EncodingT::EMPTY),
	  m_name(EncodingT::EMPTY),
	  m_textValue(EncodingT::EMPTY)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugVariableInfo ";
	}

	/** Creates a new element DebugVariableInfo.
	@param category 
	@param debugType 
	@param name 
	@param textValue 
	*/
	_DebugVariableInfo(const typename EncodingT::string_t& category,
				const typename EncodingT::string_t& debugType,
				const typename EncodingT::string_t& name,
				const typename EncodingT::string_t& textValue)
	: m_identifier(-1),
	  m_category(category),
	  m_debugType(debugType),
	  m_name(name),
	  m_textValue(textValue)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugVariableInfo "
				<< m_identifier << ' '
				<< A(m_category) << ' '
				<< A(m_debugType) << ' '
				<< A(m_name) << ' '
				<< A(m_textValue) << ' ';
	}

	/** Creates a copy of elem as the content for the DebugVariableInfo object.
	@param elem A DebugVariableInfo object containing elements of the same type.
	*/
	_DebugVariableInfo(const _DebugVariableInfo<EncodingT>& elem)
	: m_identifier(elem.m_identifier),
	  m_category(elem.m_category),
	  m_debugType(elem.m_debugType),
	  m_name(elem.m_name),
	  m_textValue(elem.m_textValue),
	  m_debugFunctionInfo(elem.m_debugFunctionInfo)
	{
		m_logger = &Category::getInstance(LOGNAME);
		m_logger->debugStream() << "constructor _DebugVariableInfo " << ": copy";
	}

	/** Assigns a copy of elem as the new content for the DebugVariableInfo object.
	@param elem A DebugVariableInfo object containing elements of the same type.
	@return *this
	*/
	_DebugVariableInfo<EncodingT>& operator=(const _DebugVariableInfo<EncodingT>& elem)  
	{
		m_identifier = elem.m_identifier;
		m_category = elem.m_category;
		m_debugType = elem.m_debugType;
		m_name = elem.m_name;
		m_textValue = elem.m_textValue;
		m_debugFunctionInfo = elem.m_debugFunctionInfo;
		return *this;
	}

	/** Returns a const reference to the element <i>identifier</i> in DebugVariableInfo.
	@return 
	*/
	int getIdentifier() const 
	{
		return m_identifier;
	}

	/** Returns a const reference to the element <i>category</i> in DebugVariableInfo.
	@return 
	*/
	const typename EncodingT::string_t& getCategory() const 
	{
		return m_category;
	}

	/** Sets a value of the element <i>category</i> in DebugVariableInfo.
	@param category 
	*/
	void setCategory(const typename EncodingT::string_t& category)  
	{
		m_category = category;
	}

	/** Returns a const reference to the element <i>debugType</i> in DebugVariableInfo.
	@return 
	*/
	const typename EncodingT::string_t& getDebugType() const 
	{
		return m_debugType;
	}

	/** Sets a value of the element <i>debugType</i> in DebugVariableInfo.
	@param debugType 
	*/
	void setDebugType(const typename EncodingT::string_t& debugType)  
	{
		m_debugType = debugType;
	}

	/** Returns a const reference to the element <i>name</i> in DebugVariableInfo.
	@return 
	*/
	const typename EncodingT::string_t& getName() const 
	{
		return m_name;
	}

	/** Sets a value of the element <i>name</i> in DebugVariableInfo.
	@param name 
	*/
	void setName(const typename EncodingT::string_t& name)  
	{
		m_name = name;
	}

	/** Returns a const reference to the element <i>textValue</i> in DebugVariableInfo.
	@return 
	*/
	const typename EncodingT::string_t& getTextValue() const 
	{
		return m_textValue;
	}

	/** Sets a value of the element <i>textValue</i> in DebugVariableInfo.
	@param textValue 
	*/
	void setTextValue(const typename EncodingT::string_t& textValue)  
	{
		m_textValue = textValue;
	}

	/** Returns a const reference to the element <i>debugFunctionInfo</i> in DebugVariableInfo.
	@return 
	*/
	boost::shared_ptr< _DebugFunctionInfo<EncodingT> > getDebugFunctionInfo() const 
	{
		return m_debugFunctionInfo;
	}

	/** Sets a value of the element <i>debugFunctionInfo</i> in DebugVariableInfo.
	@param debugFunctionInfo 
	*/
	void setDebugFunctionInfo(boost::shared_ptr< _DebugFunctionInfo<EncodingT> > debugFunctionInfo)  
	{
		m_debugFunctionInfo = debugFunctionInfo;
	}

	/** Returns whether the element <i>debugFunctionInfo</i> in DebugVariableInfo is NULL.
	@return True if the element <i>debugFunctionInfo</i> is NULL, false otherwise.
	*/
	bool isNullDebugFunctionInfo() const 
	{
		return !m_debugFunctionInfo;
	}

	/** Removes from DebugVariableInfo an element <i>debugFunctionInfo</i>.
	*/
	void eraseDebugFunctionInfo()  
	{
		m_debugFunctionInfo.reset();
	}

	/** Prints DebugVariableInfo object on a C++ stream.
	@param o Reference of C++ stream object.
	@return The reference of C++ stream object.
	*/
	ostream& printConsole(ostream& o) const 
	{
		return o << "DebugVariableInfo" << endl
		         << "identifier : " << m_identifier << endl
		         << "category : " << A(m_category) << endl
		         << "debugType : " << A(m_debugType) << endl
		         << "name : " << A(m_name) << endl
		         << "textValue : " << A(m_textValue);
	}

	/** Defines <i> operator<< </i> for DebugVariableInfo.
	@param o Reference of C++ stream object.
	@param elem Const reference of DebugVariableInfo object.
	@return The reference of C++ stream object.
	*/
	friend ostream& operator<<(ostream& o, const _DebugVariableInfo<EncodingT>& elem)  
	{
		return elem.printConsole(o<<"[ ")<<" ]";
	}

	class DebugVariableInfoIDEquality;
	class CategoryEquality;
	class CategoryInferior;
	class CategorySuperior;
	class DebugTypeEquality;
	class DebugTypeInferior;
	class DebugTypeSuperior;
	class NameEquality;
	class NameInferior;
	class NameSuperior;
	class TextValueEquality;
	class TextValueInferior;
	class TextValueSuperior;
};

typedef _DebugVariableInfo<ucs> UniDebugVariableInfo;
typedef _DebugVariableInfo<ansi> DebugVariableInfo;

NAMESPACE_END

#undef C
#undef A

#include "debugVariableInfoPredicate.hpp"

#endif
